[{"path":"https://idsia.github.io/bayesRecon/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU Lesser General Public License","title":"GNU Lesser General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed. version GNU Lesser General Public License incorporates terms conditions version 3 GNU General Public License, supplemented additional permissions listed .","code":""},{"path":"https://idsia.github.io/bayesRecon/LICENSE.html","id":"id_0-additional-definitions","dir":"","previous_headings":"","what":"0. Additional Definitions","title":"GNU Lesser General Public License","text":"used herein, “License” refers version 3 GNU Lesser General Public License, “GNU GPL” refers version 3 GNU General Public License. “Library” refers covered work governed License, Application Combined Work defined . “Application” work makes use interface provided Library, otherwise based Library. Defining subclass class defined Library deemed mode using interface provided Library. “Combined Work” work produced combining linking Application Library. particular version Library Combined Work made also called “Linked Version”. “Minimal Corresponding Source” Combined Work means Corresponding Source Combined Work, excluding source code portions Combined Work , considered isolation, based Application, Linked Version. “Corresponding Application Code” Combined Work means object code /source code Application, including data utility programs needed reproducing Combined Work Application, excluding System Libraries Combined Work.","code":""},{"path":"https://idsia.github.io/bayesRecon/LICENSE.html","id":"id_1-exception-to-section-3-of-the-gnu-gpl","dir":"","previous_headings":"","what":"1. Exception to Section 3 of the GNU GPL","title":"GNU Lesser General Public License","text":"may convey covered work sections 3 4 License without bound section 3 GNU GPL.","code":""},{"path":"https://idsia.github.io/bayesRecon/LICENSE.html","id":"id_2-conveying-modified-versions","dir":"","previous_headings":"","what":"2. Conveying Modified Versions","title":"GNU Lesser General Public License","text":"modify copy Library, , modifications, facility refers function data supplied Application uses facility (argument passed facility invoked), may convey copy modified version: ) License, provided make good faith effort ensure , event Application supply function data, facility still operates, performs whatever part purpose remains meaningful, b) GNU GPL, none additional permissions License applicable copy.","code":""},{"path":"https://idsia.github.io/bayesRecon/LICENSE.html","id":"id_3-object-code-incorporating-material-from-library-header-files","dir":"","previous_headings":"","what":"3. Object Code Incorporating Material from Library Header Files","title":"GNU Lesser General Public License","text":"object code form Application may incorporate material header file part Library. may convey object code terms choice, provided , incorporated material limited numerical parameters, data structure layouts accessors, small macros, inline functions templates (ten fewer lines length), following: ) Give prominent notice copy object code Library used Library use covered License. b) Accompany object code copy GNU GPL license document.","code":""},{"path":"https://idsia.github.io/bayesRecon/LICENSE.html","id":"id_4-combined-works","dir":"","previous_headings":"","what":"4. Combined Works","title":"GNU Lesser General Public License","text":"may convey Combined Work terms choice , taken together, effectively restrict modification portions Library contained Combined Work reverse engineering debugging modifications, also following: ) Give prominent notice copy Combined Work Library used Library use covered License. b) Accompany Combined Work copy GNU GPL license document. c) Combined Work displays copyright notices execution, include copyright notice Library among notices, well reference directing user copies GNU GPL license document. d) one following: 0) Convey Minimal Corresponding Source terms License, Corresponding Application Code form suitable , terms permit, user recombine relink Application modified version Linked Version produce modified Combined Work, manner specified section 6 GNU GPL conveying Corresponding Source. 1) Use suitable shared library mechanism linking Library. suitable mechanism one () uses run time copy Library already present user’s computer system, (b) operate properly modified version Library interface-compatible Linked Version. e) Provide Installation Information, otherwise required provide information section 6 GNU GPL, extent information necessary install execute modified version Combined Work produced recombining relinking Application modified version Linked Version. (use option 4d0, Installation Information must accompany Minimal Corresponding Source Corresponding Application Code. use option 4d1, must provide Installation Information manner specified section 6 GNU GPL conveying Corresponding Source.)","code":""},{"path":"https://idsia.github.io/bayesRecon/LICENSE.html","id":"id_5-combined-libraries","dir":"","previous_headings":"","what":"5. Combined Libraries","title":"GNU Lesser General Public License","text":"may place library facilities work based Library side side single library together library facilities Applications covered License, convey combined library terms choice, following: ) Accompany combined library copy work based Library, uncombined library facilities, conveyed terms License. b) Give prominent notice combined library part work based Library, explaining find accompanying uncombined form work.","code":""},{"path":"https://idsia.github.io/bayesRecon/LICENSE.html","id":"id_6-revised-versions-of-the-gnu-lesser-general-public-license","dir":"","previous_headings":"","what":"6. Revised Versions of the GNU Lesser General Public License","title":"GNU Lesser General Public License","text":"Free Software Foundation may publish revised /new versions GNU Lesser General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Library received specifies certain numbered version GNU Lesser General Public License “later version” applies , option following terms conditions either published version later version published Free Software Foundation. Library received specify version number GNU Lesser General Public License, may choose version GNU Lesser General Public License ever published Free Software Foundation. Library received specifies proxy can decide whether future versions GNU Lesser General Public License shall apply, proxy’s public statement acceptance version permanent authorization choose version Library.","code":""},{"path":"https://idsia.github.io/bayesRecon/TODO.html","id":null,"dir":"","previous_headings":"","what":"To Do file for package","title":"To Do file for package","text":"2023-03-30","code":""},{"path":"https://idsia.github.io/bayesRecon/TODO.html","id":"general","dir":"","previous_headings":"","what":"General","title":"To Do file for package","text":"Create test case .fix_weights returns warning. Decide notation upper vs aggregate Add start temporal aggregation Remove bullet points argument descriptions Vignettes: comparison MCMC BUIS different hierarchies tscounts","code":""},{"path":"https://idsia.github.io/bayesRecon/TODO.html","id":"docs","dir":"","previous_headings":"","what":"Docs","title":"To Do file for package","text":"Docs MCMC: add link/reference MCMC convergence checks update README badges, installation make github public: add getting help contribute sections README","code":""},{"path":"https://idsia.github.io/bayesRecon/TODO.html","id":"long-term-to-do","dir":"","previous_headings":"","what":"Long term to do","title":"To Do file for package","text":"add usethis::use_github_action() Change documentation reconc_buis reconc_mcmc: distr can list strings (also in_type?) Check list distributions (bottom continuous, upper must continuous) Control effective sample size check weights collapse Extension batch-BUIS? check use parallel computation local cores batch BUIS. Add zero-inflation Add “fixed forecast” (.e. Dirac delta)","code":""},{"path":"https://idsia.github.io/bayesRecon/articles/bayesRecon.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Probabilistic Reconciliation via Conditioning with `bayesRecon`","text":"vignette shows perform probabilistic reconciliation bayesRecon package. provide three examples: Temporal hierarchy count time series: build temporal hierarchy count time series, produce base forecasts using glarma reconcile via Bottom-Importance Sampling (BUIS). Temporal hierarchy smooth time series: build temporal hierarchy smooth time series, compute base forecasts using ets reconcile closed form using Gaussian reconciliation. covariance matrix diagonal. Hierarchical smooth time series: example cross-sectional hierarchy. generate base forecasts using ets reconcile via Gaussian reconciliation. covariance matrix full estimated via shrinkage.","code":""},{"path":"https://idsia.github.io/bayesRecon/articles/bayesRecon.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Probabilistic Reconciliation via Conditioning with `bayesRecon`","text":"package, available CRAN page, can installed loaded usual commands: Load package:","code":"install.packages('bayesRecon', dependencies = TRUE) library(bayesRecon)"},{"path":"https://idsia.github.io/bayesRecon/articles/bayesRecon.html","id":"temporal-hierarchy-over-a-count-time-series","dir":"Articles","previous_headings":"","what":"Temporal hierarchy over a count time series","title":"Probabilistic Reconciliation via Conditioning with `bayesRecon`","text":"select monthly time series counts carparts dataset, available expsmooth package (R. J. Hyndman 2015). data set contains time series sales cars part Jan. 1998 Mar. 2002. example select time series #2655, make available bayesRecon::carparts_example. time series skewed distribution values. Figure 1: Carpart - monthly car part sales. divide time series train test; test set contains last 12 months. build temporal hierarchy using temporal aggregation function. specify aggregation levels using agg_levels argument; case 2-Monthly, Quarterly, 4-Monthly, Biannual, Annual. function returns list aggregated time series, ordered aggregated (top hierarchy) disagreggated (bottom hierarchy). plot . Figure 2: aggregated time series temporal hierarchy. compute base forecasts using package glarma, package specific forecasting count time series. forecast 12 steps ahead monthly level, 4 steps ahead quarterly level, etc. iterating levels hierarchy, level, fit glarma model Poisson predictive distribution forecast; forecast constituted 20000 integer samples. Eventually collect samples 28 predictive distributions (one Annual level, two Biannual level, etc.) list. code takes 30 seconds standard computer. Reconciliation requires aggregation matrix 𝐀\\mathbf{}, obtain using function get_reconc_matrices. requires: aggregation factors hierarchy, example {2,3,4,6,12}\\{2, 3, 4, 6, 12\\}; length forecasting horizon bottom level, 12 example. reconcile using Bottom-Important Sampling (BUIS) use function reconc_BUIS, passing 𝐀\\mathbf{} matrix, base forecasts, type base forecasts (in_type=“samples”) whether samples continuous discrete (distr = “discrete”). obtain samples reconciled forecast distribution. now compute Mean Absolute Error (MAE) Continuous Ranked Probability Score (CRPS) bottom (.e., monthly) time series. computing CRPS, use package scoringRules.","code":"layout(mat = matrix(c(1, 2), nrow = 1, ncol = 2), widths = c(2, 1)) plot(carparts_example, xlab = \"Time\", ylab = \"Car part sales\", main = NULL) hist(carparts_example, xlab = \"Car part sales\", main = NULL) train <- window(carparts_example, end = c(2001, 3)) test  <- window(carparts_example, start = c(2001, 4)) train.agg <- bayesRecon::temporal_aggregation(train, agg_levels = c(2, 3, 4, 6, 12)) levels <- c(\"Annual\", \"Biannual\", \"4-Monthly\", \"Quarterly\", \"2-Monthly\", \"Monthly\") names(train.agg) <- levels par(mfrow = c(2, 3), mai = c(0.6, 0.6, 0.5, 0.5)) for (l in levels) {   plot(train.agg[[l]], xlab = \"Time\", ylab = \"Car part sales\", main = l) } # install.packages(\"glarma\", dependencies = TRUE) #library(glarma)  fc.samples <- list() D <- 20000 fc.count <- 1  # iterating over the temporal aggregation levels for (l in seq_along(train.agg)) {   f.level <- frequency(train.agg[[l]])   print(paste(\"Forecasting at \", levels[l], \"...\", sep = \"\"))   # fit an independent model for each aggregation level   model <- glarma::glarma(     train.agg[[l]],     phiLags = if (f.level == 1) 1 else 1:(min(6, f.level - 1)),     thetaLags = if (f.level == 1) NULL else f.level,     X = cbind(intercept = rep(1, length(train.agg[[l]]))),     offset = cbind(intercept = rep(0, length(train.agg[[l]]))),     type = \"Poi\"   )   # forecast 1 year ahead   h <- f.level   tmp <- matrix(data = NA, nrow = h, ncol = D)   for (s in (1:D)) {     # each call to 'forecast.glarma' returns a simulation path     tmp[, s] <- glarma::forecast(       model,       n.ahead = h,       newdata = cbind(intercept = rep(1, h)),       newoffset = rep(0, h)     )$Y   }   # collect the forecasted samples   for (i in 1:h) {     fc.samples[[fc.count]] <- tmp[i, ]     fc.count <- fc.count + 1   } } #> [1] \"Forecasting at Annual...\" #> [1] \"Forecasting at Biannual...\" #> [1] \"Forecasting at 4-Monthly...\" #> [1] \"Forecasting at Quarterly...\" #> [1] \"Forecasting at 2-Monthly...\" #> [1] \"Forecasting at Monthly...\" recon.matrices <- bayesRecon::get_reconc_matrices(agg_levels = c(2, 3, 4, 6, 12), h = 12) # Aggregation matrix A <- recon.matrices$A recon.res <- bayesRecon::reconc_BUIS(   A,   base_forecasts = fc.samples,   in_type = \"samples\",   distr = \"discrete\",   seed = 42 ) reconciled_samples <- recon.res$reconciled_samples dim(reconciled_samples) #> [1]    28 20000 # install.packages(\"scoringRules\", dependencies = TRUE) library(scoringRules)  ae.fc <- list() ae.reconc <- list() crps.fc <- list() crps.reconc <- list() for (h in 1:length(test)) {   y.hat_ <- median(fc.samples[[nrow(A) + h]])   y.reconc_ <- median(recon.res$bottom_reconciled_samples[h,])   # Compute Absolute Errors   ae.fc[[h]] <- abs(test[h] - y.hat_)   ae.reconc[[h]] <- abs(test[h] - y.reconc_)   # Compute Continuous Ranked Probability Score (CRPS)   crps.fc[[h]] <-     scoringRules::crps_sample(y = test[h], dat = fc.samples[[nrow(A) + h]])   crps.reconc[[h]] <-     scoringRules::crps_sample(y = test[h], dat = recon.res$bottom_reconciled_samples[h,]) }  mae.fc <- mean(unlist(ae.fc)) mae.reconc <- mean(unlist(ae.reconc)) crps.fc <- mean(unlist(crps.fc)) crps.reconc <- mean(unlist(crps.reconc)) metrics <- data.frame(   row.names = c(\"MAE\", \"CRPS\"),   base.forecasts = c(mae.fc, crps.fc),   reconciled.forecasts = c(mae.reconc, crps.reconc) ) metrics #>      base.forecasts reconciled.forecasts #> MAE       1.2500000            1.0000000 #> CRPS      0.7093284            0.6509691"},{"path":"https://idsia.github.io/bayesRecon/articles/bayesRecon.html","id":"temporal-hierarchy-over-a-smooth-time-series","dir":"Articles","previous_headings":"","what":"Temporal hierarchy over a smooth time series","title":"Probabilistic Reconciliation via Conditioning with `bayesRecon`","text":"second example, select smooth monthly time series (N1485) M3 forecasting competition (Makridakis Hibon 2000). data set available Mcomp package (R. Hyndman 2018) make available time series bayesRecon::M3_example. Figure 3: M3 - N1485 time series. build temporal hierarchy using temporal_aggregation function. Without specifying agg_levels, function generates default feasible aggregation: 2-Monthly, Quarterly, 4-Monthly, Biannual, Annual. generate base forecasts using ets forecast package (R. J. Hyndman Khandakar 2008). every level predict 18 months ahead. predictive distributions Gaussian. Using function get_reconc_matrices, get matrix 𝐀\\mathbf{}. Figure 4: M3 - aggregation matrix (red=1, yellow=0). function reconc_gaussian implements exact Gaussian reconciliation. also run reconc_BUIS, check consistency two approaches. now compare base forecasts reconciled forecasts: Figure 5: M3 - Base reconciled forecasts. black line shows actual data (dashed test). orange line mean base forecasts, blu line reconciled mean. also show 95% prediction intervals.","code":"plot(M3_example$train, xlab = \"Time\", ylab = \"y\", main = \"N1485\") train.agg <- bayesRecon::temporal_aggregation(M3_example$train) levels <- c(\"Annual\", \"Biannual\", \"4-Monthly\", \"Quarterly\", \"2-Monthly\", \"Monthly\") names(train.agg) <- levels # install.packages(\"forecast\", dependencies = TRUE) library(forecast) #> Registered S3 method overwritten by 'quantmod': #>   method            from #>   as.zoo.data.frame zoo  H <- length(M3_example$test) H #> [1] 18  fc <- list() level.idx <- 1 fc.idx <- 1 for (level in train.agg) {   level.name <- names(train.agg)[level.idx]   # fit an ETS model for each temporal level   model <- ets(level)   # generate forecasts for each level within 18 months   h <- floor(H / (12 / frequency(level)))   print(paste(\"Forecasting at \", level.name, \", h=\", h, \"...\", sep = \"\"))   level.fc <- forecast(model, h = h)   # save mean and sd of the gaussian predictive distribution   for (i in 1:h) {     fc[[fc.idx]] <- list(mean = level.fc$mean[[i]],                          sd = (level.fc$upper[, \"95%\"][[i]] - level.fc$mean[[i]]) / qnorm(0.975))     fc.idx <- fc.idx + 1   }   level.idx <- level.idx + 1 } #> [1] \"Forecasting at Annual, h=1...\" #> [1] \"Forecasting at Biannual, h=3...\" #> [1] \"Forecasting at 4-Monthly, h=4...\" #> [1] \"Forecasting at Quarterly, h=6...\" #> [1] \"Forecasting at 2-Monthly, h=9...\" #> [1] \"Forecasting at Monthly, h=18...\" rmat <- get_reconc_matrices(agg_levels = c(2, 3, 4, 6, 12), h = 18)  par(mai = c(1,1,0.5,0.5)) image(1:ncol(rmat$A), 1:nrow(rmat$A),        t(apply(t(rmat$A),1,rev)),        xaxt='n', yaxt='n', ylab = \"\", xlab = levels[6]) axis(1, at=1:ncol(rmat$A), label=1:ncol(rmat$A), las=1) axis(2, at=c(23,22,19,15,9), label=levels[1:5], las=2) recon.gauss <- bayesRecon::reconc_gaussian(   A = rmat$A,   base_forecasts.mu = sapply(fc, \"[[\", 1),   base_forecasts.Sigma = diag(sapply(fc, \"[[\", 2)) ^ 2 )  reconc.buis <- bayesRecon::reconc_BUIS(   A = rmat$A,   base_forecasts = fc,   in_type = \"params\",   distr = \"gaussian\",   num_samples = 20000,   seed = 42 )  # check that the algorithms return consistent results round(rbind(   c(rmat$S %*% recon.gauss$bottom_reconciled_mean),   rowMeans(reconc.buis$reconciled_samples) )) #>       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9] [,10] [,11] [,12] #> [1,] 74977 35913 39063 41491 23520 25136 26321 27174 17464 18450 19251 19812 #> [2,] 74946 35897 39049 41470 23532 25091 26323 27134 17462 18435 19231 19818 #>      [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] #> [1,] 20412 21079 11527 11993 12393 12743 13047 13274 13531 13643 14317  5694 #> [2,] 20425 21046 11547 11985 12365 12726 13041 13282 13482 13652 14336  5694 #>      [,25] [,26] [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] #> [1,]  5833  5936  6056  6138  6255  6324  6419  6508  6538  6619  6655  6759 #> [2,]  5853  5914  6070  6127  6237  6308  6418  6505  6536  6612  6670  6729 #>      [,37] [,38] [,39] [,40] [,41] #> [1,]  6772  6881  6762  7160  7157 #> [2,]  6753  6943  6709  7152  7184 yhat.mu <- tail(sapply(fc, \"[[\", 1), 18) yhat.sigma <- tail(sapply(fc, \"[[\", 2), 18) yhat.hi95 <- qnorm(0.975, mean = yhat.mu, sd = yhat.sigma) yhat.lo95 <- qnorm(0.025, mean = yhat.mu, sd = yhat.sigma) yreconc.mu <- rowMeans(reconc.buis$bottom_reconciled_samples) yreconc.hi95 <- apply(reconc.buis$bottom_reconciled_samples, 1,                        function(x) quantile(x, 0.975)) yreconc.lo95 <- apply(reconc.buis$bottom_reconciled_samples, 1,                        function(x) quantile(x, 0.025))  ylim_ <- c(min(M3_example$train, M3_example$test, yhat.lo95, yreconc.lo95) - 1,             max(M3_example$train, M3_example$test, yhat.hi95, yreconc.hi95) + 1)  plot(M3_example$train, xlim = c(1990, 1995.6), ylim = ylim_,       ylab = \"y\", main = \"N1485 Forecasts\") lines(M3_example$test, lty = \"dashed\") lines(ts(yhat.mu, start = start(M3_example$test), frequency = 12),        col = \"coral\", lwd = 2) lines(ts(yreconc.mu, start = start(M3_example$test), frequency = 12),        col = \"blue2\", lwd = 2) xtest <- time(M3_example$test) polygon(c(xtest, rev(xtest)), c(yhat.mu, rev(yhat.hi95)),          col = \"#FF7F5066\", border = \"#FF7F5066\") polygon(c(xtest, rev(xtest)), c(yhat.mu, rev(yhat.lo95)),          col = \"#FF7F5066\", border = \"#FF7F5066\") polygon(c(xtest, rev(xtest)), c(yreconc.mu, rev(yreconc.hi95)),          col = \"#0000EE4D\", border = \"#0000EE4D\") polygon(c(xtest, rev(xtest)), c(yreconc.mu, rev(yreconc.lo95)),          col = \"#0000EE4D\", border = \"#0000EE4D\")"},{"path":"https://idsia.github.io/bayesRecon/articles/bayesRecon.html","id":"gaussian-reconciliation-of-a-cross-sectional-hierarchy","dir":"Articles","previous_headings":"","what":"Gaussian reconciliation of a cross-sectional hierarchy","title":"Probabilistic Reconciliation via Conditioning with `bayesRecon`","text":"example, consider hierarchical time series infantgts, available hts package (R. Hyndman et al. 2021) make available also package bayesRecon::infantMortality. contains counts infant mortality (deaths) Australia, disaggregated state sex (male female). forecast one year ahead using auto.arima forecast package. collect residuals, later use compute covariance matrix. Now build 𝐀\\mathbf{} matrix. Figure 6: Infants mortality - aggregation matrix (red=1, yellow=0). use bayesRecon::schaferStrimmer_cov estimate covariance matrix residuals shrinkage (Schäfer Strimmer 2005). now perform Gaussian reconciliation:","code":"# install.packages(\"forecast\", dependencies = TRUE) library(forecast)  fc <- list() residuals <- matrix(NA,                     nrow = length(infantMortality$total),                     ncol = length(infantMortality)) fc.idx <- 1 for (s in infantMortality) {   s.name <- names(infantMortality)[fc.idx]   print(paste(\"Forecasting at \", s.name, \"...\", sep = \"\"))   # fit an auto.arima model and forecast with h=1   model <- auto.arima(s)   s.fc <- forecast(model, h = 1)   # save mean and sd of the gaussian predictive distribution   fc[[s.name]] <- c(s.fc$mean,                     (s.fc$upper[, \"95%\"][[1]] - s.fc$mean) / qnorm(0.975))   residuals[, fc.idx] <- s.fc$residuals   fc.idx <- fc.idx + 1 } #> [1] \"Forecasting at total...\" #> [1] \"Forecasting at NSW...\" #> [1] \"Forecasting at VIC...\" #> [1] \"Forecasting at QLD...\" #> [1] \"Forecasting at SA...\" #> [1] \"Forecasting at WA...\" #> [1] \"Forecasting at NT...\" #> [1] \"Forecasting at ACT...\" #> [1] \"Forecasting at TAS...\" #> [1] \"Forecasting at male...\" #> [1] \"Forecasting at female...\" #> [1] \"Forecasting at NSW male...\" #> [1] \"Forecasting at NSW female...\" #> [1] \"Forecasting at VIC male...\" #> [1] \"Forecasting at VIC female...\" #> [1] \"Forecasting at QLD male...\" #> [1] \"Forecasting at QLD female...\" #> [1] \"Forecasting at SA male...\" #> [1] \"Forecasting at SA female...\" #> [1] \"Forecasting at WA male...\" #> [1] \"Forecasting at WA female...\" #> [1] \"Forecasting at NT male...\" #> [1] \"Forecasting at NT female...\" #> [1] \"Forecasting at ACT male...\" #> [1] \"Forecasting at ACT female...\" #> [1] \"Forecasting at TAS male...\" #> [1] \"Forecasting at TAS female...\" # we have 16 bottom time series, and 11 upper time series A <- matrix(data = c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,                      1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,                      0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,                      0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,                      0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,                      0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,                      0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,                      0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,                      1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,                      0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1), byrow=TRUE, ncol = 16)  # plot of A par(mai = c(1.5,1,0.5,0.5)) image(1:ncol(A), 1:nrow(A),        t(apply(t(A),1,rev)),        xaxt='n', yaxt='n', ann=FALSE) axis(1, at=1:ncol(A), label=names(infantMortality)[12:27], las=2) axis(2, at=c(1:11), label=rev(names(infantMortality)[1:11]), las=2) # means mu <- sapply(fc, \"[[\", 1) # Shrinkage covariance shrink.res <- bayesRecon::schaferStrimmer_cov(residuals) print(paste(\"The estimated shrinkage intensity is\", round(shrink.res$lambda_star, 3))) #> [1] \"The estimated shrinkage intensity is 0.153\" Sigma <- shrink.res$shrink_cov recon.gauss <- bayesRecon::reconc_gaussian(A,                                            base_forecasts.mu = mu,                                            base_forecasts.Sigma = Sigma)  bottom_mu_reconc <- recon.gauss$bottom_reconciled_mean bottom_Sigma_reconc <- recon.gauss$bottom_reconciled_covariance  # Obtain reconciled mu and Sigma for the upper variable upper_mu_reconc <- A %*% bottom_mu_reconc upper_Sigma_reconc <- A %*% bottom_Sigma_reconc %*% t(A)  upper_mu_reconc #>            [,1] #>  [1,] 688.82408 #>  [2,] 190.05371 #>  [3,] 165.26902 #>  [4,] 173.39776 #>  [5,]  40.95861 #>  [6,]  63.82008 #>  [7,]  20.37299 #>  [8,]  17.24244 #>  [9,]  17.70948 #> [10,] 424.30287 #> [11,] 264.52121"},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/articles/mixed_reconciliation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Reconciliation of M5 hierarchy with mixed-type forecasts","text":"vignette partially reproduces results Probabilistic reconciliation mixed-type hierarchical time series (Zambon et al. 2024), published UAI 2024 (40th Conference Uncertainty Artificial Intelligence). particular, replicate reconciliation one-step ahead (h=1) forecasts one store M5 competition (Makridakis, Spiliotis, Assimakopoulos 2022). Sect. 5 paper presents results 10 stores, reconciled 14 times using rolling one-step ahead forecasts.","code":""},{"path":"https://idsia.github.io/bayesRecon/articles/mixed_reconciliation.html","id":"data-and-base-forecasts","dir":"Articles","previous_headings":"","what":"Data and base forecasts","title":"Reconciliation of M5 hierarchy with mixed-type forecasts","text":"M5 competition (Makridakis, Spiliotis, Assimakopoulos 2022) daily time series sales data referring 10 different stores. store hierarchy: 3049 bottom time series (single items) 11 upper time series, obtained aggregating items department, product category, store; see figure . Figure 1: graph M5 hierarchy. reproduce results store “CA_1”. base forecasts (h=1) bottom upper time series stored M5_CA1_basefc, available data package. base forecast computed using ADAM (Svetunkov Boylan 2023), implemented R package smooth (Svetunkov 2023).","code":"# Hierarchy composed by 3060 time series: 3049 bottom and 11 upper n_b <- 3049 n_u <- 11 n <- n_b + n_u     # Load matrix A  A <- M5_CA1_basefc$A  # Load base forecasts: base_fc_upper  <- M5_CA1_basefc$upper base_fc_bottom <- M5_CA1_basefc$bottom  # We will save all the results in the list rec_fc rec_fc <- list(             Gauss      = list(),             Mixed_cond = list(),             TD_cond    = list()           )"},{"path":"https://idsia.github.io/bayesRecon/articles/mixed_reconciliation.html","id":"gaussian-reconciliation","dir":"Articles","previous_headings":"","what":"Gaussian reconciliation","title":"Reconciliation of M5 hierarchy with mixed-type forecasts","text":"first perform Gaussian reconciliation (Gauss, Corani et al. (2021)). assumes forecasts Gaussian, even though bottom base forecasts Gaussian. assume upper base forecasts multivariate Gaussian estimate covariance matrix -sample residuals. assume also bottom base forecasts independent Gaussians. reconcile using function reconc_gaussian(), takes input: summing matrix ; means base forecast, base_forecasts.mu; covariance base forecast, base_forecasts.Sigma. function returns reconciled mean covariance bottom time series.","code":"# Parameters of the upper base forecast distributions mu_u <- unlist(lapply(base_fc_upper, \"[[\", \"mu\"))  # upper means # Compute the (shrinked) covariance matrix of the residuals residuals.upper <- lapply(base_fc_upper, \"[[\", \"residuals\") residuals.upper <- t(do.call(\"rbind\", residuals.upper)) Sigma_u <- schaferStrimmer_cov(residuals.upper)$shrink_cov    # Parameters of the bottom base forecast distributions mu_b <- c() sd_b <- c() for (fc_b in base_fc_bottom) {   pmf <- fc_b$pmf   mu_b <- c(mu_b, PMF.get_mean(pmf))   sd_b <- c(sd_b, PMF.get_var(pmf)**0.5) } Sigma_b <- diag(sd_b**2)  # Mean and covariance matrix of the base forecasts base_forecasts.mu <- c(mu_u,mu_b) base_forecasts.Sigma <- matrix(0, nrow = n, ncol = n) base_forecasts.Sigma[1:n_u,1:n_u] <- Sigma_u base_forecasts.Sigma[(n_u+1):n,(n_u+1):n] <- Sigma_b # Gaussian reconciliation  start <- Sys.time()        gauss <- reconc_gaussian(A, base_forecasts.mu, base_forecasts.Sigma) stop <- Sys.time()  rec_fc$Gauss <- list(mu_b    = gauss$bottom_reconciled_mean,                      Sigma_b = gauss$bottom_reconciled_covariance,                      mu_u    = A %*% gauss$bottom_reconciled_mean,                      Sigma_u = A %*% gauss$bottom_reconciled_covariance %*% t(A))  Gauss_time <- as.double(round(difftime(stop, start, units = \"secs\"), 2)) cat(\"Time taken by Gaussian reconciliation: \", Gauss_time, \"s\") #> Time taken by Gaussian reconciliation:  0.31 s"},{"path":"https://idsia.github.io/bayesRecon/articles/mixed_reconciliation.html","id":"reconciliation-with-mixed-conditioning","dir":"Articles","previous_headings":"","what":"Reconciliation with mixed-conditioning","title":"Reconciliation of M5 hierarchy with mixed-type forecasts","text":"now reconcile forecasts using mixed-conditioning approach Zambon et al. (2024), Sect. 3. algorithm implemented function reconc_MixCond(). function takes input: aggregation matrix ; probability mass functions bottom base forecasts, stored list fc_bottom_4rec; parameters multivariate Gaussian distribution upper variables, fc_upper_4rec; additional function parameters; among note num_samples specifies number samples used internal importance sampling () algorithm. function returns reconciled forecasts form probability mass functions upper bottom time series. function parameter return_type can changed samples obtain samples. discussed Zambon et al. (2024), Sect. 3, conditioning mixed variables performs poorly high dimensions. bottom-distribution, built assuming bottom forecasts independent, untenable high dimensions. Moreover, forecasts count time series usually biased sum tends strongly biased; see Zambon et al. (2024), Fig. 3, graphical example.","code":"seed <- 1 N_samples_IS <- 5e4  # Base forecasts fc_upper_4rec <- list(mu=mu_u, Sigma=Sigma_u) fc_bottom_4rec <- lapply(base_fc_bottom, \"[[\", \"pmf\")  # list of PMFs  # MixCond reconciliation start <- Sys.time()        mix_cond <- reconc_MixCond(A, fc_bottom_4rec, fc_upper_4rec, bottom_in_type = \"pmf\",                           num_samples = N_samples_IS, return_type = \"pmf\", seed = seed) stop <- Sys.time()         rec_fc$Mixed_cond <- list(   bottom = mix_cond$bottom_reconciled$pmf,   upper  = mix_cond$upper_reconciled$pmf,   ESS    = mix_cond$ESS   )  MixCond_time <- as.double(round(difftime(stop, start, units = \"secs\"), 2)) cat(\"Computational time for Mix-cond reconciliation: \", MixCond_time, \"s\") #> Computational time for Mix-cond reconciliation:  9.6 s"},{"path":"https://idsia.github.io/bayesRecon/articles/mixed_reconciliation.html","id":"top-down-conditioning","dir":"Articles","previous_headings":"","what":"Top down conditioning","title":"Reconciliation of M5 hierarchy with mixed-type forecasts","text":"Top conditioning (TD-cond; see Zambon et al. (2024), Sect. 4) reliable approach reconciling mixed variables high dimensions. algorithm implemented function reconc_TDcond(); takes arguments reconc_MixCond() returns reconciled forecasts format. algorithm TD-cond raises warning regarding incoherence joint bottom-upper base forecasts. see warning impact performances TD-cond.","code":"N_samples_TD <- 1e4  # TDcond reconciliation start <- Sys.time()      td <- reconc_TDcond(A, fc_bottom_4rec, fc_upper_4rec,                    bottom_in_type = \"pmf\", num_samples = N_samples_TD,                     return_type = \"pmf\", seed = seed) #> Warning in reconc_TDcond(A, fc_bottom_4rec, fc_upper_4rec, bottom_in_type = #> \"pmf\", : Only 99.4% of the upper samples are in the support of the bottom-up #> distribution; the others are discarded. stop <- Sys.time() rec_fc$TD_cond <- list(   bottom = td$bottom_reconciled$pmf,   upper  = td$upper_reconciled$pmf   )  TDCond_time <- as.double(round(difftime(stop, start, units = \"secs\"), 2)) cat(\"Computational time for TD-cond reconciliation: \", TDCond_time, \"s\") #> Computational time for TD-cond reconciliation:  10.32 s"},{"path":"https://idsia.github.io/bayesRecon/articles/mixed_reconciliation.html","id":"comparison","dir":"Articles","previous_headings":"","what":"Comparison","title":"Reconciliation of M5 hierarchy with mixed-type forecasts","text":"computational time required Gaussian reconciliation 0.31 seconds, Mix-cond requires 9.6 seconds TD-cond requires 10.32 seconds. time series hierarchy, compute following scores method: MASE: Mean Absolute Scaled Error MIS: Mean Interval Score RPS: Ranked Probability Score following functions used computing scores: AE_pmf: compute absolute error PMF; MIS_pmf: compute interval score PMF; RPS_pmf: compute RPS PMF; MIS_gauss: compute MIS Gaussian distribution. implementation functions available source code vignette shown .","code":"# Parameters for computing the scores alpha <- 0.1   # MIS uses 90% coverage intervals jitt <- 1e-9   # jitter for numerical stability   # Save actual values actuals_u <- unlist(lapply(base_fc_upper, \"[[\", \"actual\")) actuals_b <- unlist(lapply(base_fc_bottom, \"[[\", \"actual\")) actuals <- c(actuals_u, actuals_b)  # Scaling factor for computing MASE Q_u <- M5_CA1_basefc$Q_u Q_b <- M5_CA1_basefc$Q_b Q   <- c(Q_u, Q_b)  # Initialize lists to save the results mase <- list() mis  <- list() rps  <- list() # Compute scores for the base forecasts # Upper mu_u <- unlist(lapply(base_fc_upper, \"[[\", \"mu\")) sd_u <- unlist(lapply(base_fc_upper, \"[[\", \"sigma\")) mase$base[1:n_u] <- abs(mu_u - actuals_u) / Q_u mis$base[1:n_u]  <- MIS_gauss(mu_u, sd_u, actuals_u, alpha) rps$base[1:n_u]  <- scoringRules::crps(actuals_u, \"norm\", mean=mu_u, sd=sd_u) # Bottom pmfs = lapply(base_fc_bottom, \"[[\", \"pmf\") mase$base[(n_u+1):n] <- mapply(AE_pmf, pmfs, actuals_b) / Q_b mis$base[(n_u+1):n]  <- mapply(MIS_pmf, pmfs, actuals_b, MoreArgs = list(alpha=alpha)) rps$base[(n_u+1):n]  <- mapply(RPS_pmf, pmfs, actuals_b)  # Compute scores for Gauss reconciliation mu <- c(rec_fc$Gauss$mu_u, rec_fc$Gauss$mu_b) sd <- c(diag(rec_fc$Gauss$Sigma_u), diag(rec_fc$Gauss$Sigma_b))**0.5 sd <- sd + jitt mase$Gauss <- abs(mu - actuals) / Q mis$Gauss <- MIS_gauss(mu, sd, actuals, alpha) rps$Gauss <- scoringRules::crps(actuals, \"norm\", mean=mu, sd=sd)  # Compute scores for Mix-cond reconciliation pmfs <- c(rec_fc$Mixed_cond$upper, rec_fc$Mixed_cond$bottom) mase$MixCond <- mapply(AE_pmf, pmfs, actuals) / Q mis$MixCond  <- mapply(MIS_pmf, pmfs, actuals, MoreArgs = list(alpha=alpha)) rps$MixCond  <- mapply(RPS_pmf, pmfs, actuals)  # Compute scores for TD-cond reconciliation pmfs <- c(rec_fc$TD_cond$upper, rec_fc$TD_cond$bottom) mase$TDcond <- mapply(AE_pmf, pmfs, actuals) / Q mis$TDcond  <- mapply(MIS_pmf, pmfs, actuals, MoreArgs = list(alpha=alpha)) rps$TDcond  <- mapply(RPS_pmf, pmfs, actuals)"},{"path":"https://idsia.github.io/bayesRecon/articles/mixed_reconciliation.html","id":"skill-scores","dir":"Articles","previous_headings":"Comparison","what":"Skill scores","title":"Reconciliation of M5 hierarchy with mixed-type forecasts","text":"report improvement base forecasts using skill score values averaging across experiments. instance, skill score Gauss RPS : Skill%(RPS, Gauss)=100⋅RPS(base)−RPS(Gauss)(RPS(base)+RPS(Gauss))/2 \\text{Skill}_{\\%}\\,(\\text{RPS, }Gauss) = 100 \\cdot \\frac{\\text{RPS}(base) - \\text{RPS}(Gauss)} {(\\text{RPS}(base) + \\text{RPS}(Gauss))/2} formula implemented function skill.score, available source code vignette shown . report tables mean values skill score. Mean skill score MASE. mean MASE skill score positive TD-cond reconciliation. Mix-cond Gauss achieve scores lower base forecasts, even Mix-cond degrades less base forecasts compared Gauss. Mean skill score MIS. mean MIS score TD-cond slightly base forecasts. Mix-cond achieves slightly higher scores base forecasts bottom variables. Gauss strongly degrades base forecasts according metric. Mean skill score RPS. mean RPS skill score TD-cond positive upper bottom time series. Mix-cond slightly improves base forecasts bottom variables, however degrades upper base forecasts. Gauss strongly degrades upper bottom base forecasts.","code":"scores <- list(         mase = mase,         mis  = mis,         rps = rps       ) scores_ = names(scores)  ref_met  <- \"base\" methods_ <- c(\"Gauss\", \"MixCond\", \"TDcond\")  # For each score and method we compute the skill score with respect to the base forecasts skill_scores <- list() for (s in scores_) {   skill_scores[[s]] <- list()   for (met in methods_) {     skill_scores[[s]][[\"upper\"]][[met]] <- skill.score(scores[[s]][[ref_met]][1:n_u],                                                         scores[[s]][[met]][1:n_u])     skill_scores[[s]][[\"bottom\"]][[met]] <- skill.score(scores[[s]][[ref_met]][(n_u+1):n],                                                          scores[[s]][[met]][(n_u+1):n])     } } mean_skill_scores <- list()  for (s in scores_) {   mean_skill_scores[[s]] <- rbind(data.frame(lapply(skill_scores[[s]][[\"upper\"]], mean)),                                     data.frame(lapply(skill_scores[[s]][[\"bottom\"]], mean))                                      )   rownames(mean_skill_scores[[s]]) <- c(\"upper\",\"bottom\") } knitr::kable(mean_skill_scores$mase,digits = 2,caption = \"Mean skill score on MASE.\",align = 'lccc') knitr::kable(mean_skill_scores$mis,digits = 2,caption = \"Mean skill score on MIS.\") knitr::kable(mean_skill_scores$rps,digits = 2,caption = \"Mean skill score on RPS.\")"},{"path":"https://idsia.github.io/bayesRecon/articles/mixed_reconciliation.html","id":"boxplots","dir":"Articles","previous_headings":"Comparison","what":"Boxplots","title":"Reconciliation of M5 hierarchy with mixed-type forecasts","text":"Finally, show boxplots skill scores method divided upper bottom levels. Figure 2: boxplot MASE skill scores upper bottom time series. Mix-cond TD-cond improve bottom MASE base forecasts (boxplot flattened value zero), however TD-cond provides slight improvement upper base forecasts (boxplot zero line). Figure 3: boxplot MIS skill scores upper bottom time series. Mix-cond TD-cond improve degrade bottom base forecasts MIS score shown small boxplots centered around zero. upper variables instead TD-cond degrade MIS score base forecasts. Figure 4: boxplot RPS skill scores upper bottom time series. According RPS, TD-cond degrade bottom base forecasts improves upper base forecasts. hand Gauss Mix-cond strongly degrade upper base forecasts.","code":"custom_colors <- c(\"#a8a8e4\",                    \"#a9c7e4\",                   \"#aae4df\")  # Boxplots of MASE skill scores par(mfrow = c(2, 1)) boxplot(skill_scores$mase$upper, main = \"MASE upper time series\",          col = custom_colors, ylim = c(-80,80)) abline(h=0,lty=3) boxplot(skill_scores$mase$bottom, main = \"MASE bottom time series\",          col = custom_colors, ylim = c(-200,200)) abline(h=0,lty=3) # Boxplots of MIS skill scores par(mfrow = c(2, 1)) boxplot(skill_scores$mis$upper, main = \"MIS upper time series\",          col = custom_colors, ylim = c(-150,150)) abline(h=0,lty=3) boxplot(skill_scores$mis$bottom, main = \"MIS bottom time series\",          col = custom_colors, ylim = c(-200,200)) abline(h=0,lty=3) # Boxplots of RPS skill scores par(mfrow = c(2,1)) boxplot(skill_scores$rps$upper, main = \"RPS upper time series\",          col = custom_colors, ylim = c(-80,80)) abline(h=0,lty=3) boxplot(skill_scores$rps$bottom, main = \"RPS bottom time series\",          col = custom_colors, ylim = c(-200,200)) abline(h=0,lty=3)"},{"path":"https://idsia.github.io/bayesRecon/articles/mixed_reconciliation.html","id":"full-reproducibility","dir":"Articles","previous_headings":"","what":"Full reproducibility","title":"Reconciliation of M5 hierarchy with mixed-type forecasts","text":"full experiment described (Zambon et al. 2024) can reproduced using code available .","code":""},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/articles/reconciliation_properties.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Properties of the reconciled distribution via conditioning","text":"vignette reproduces results paper Properties reconciled distributions Gaussian count forecasts (Zambon et al. 2024), accepted publication International Journal Forecasting. replicate main experiment paper (see sec. 3, Zambon et al. (2024)) reconcile base forecasts constituted negative binomial distributions. use R package BayesRecon.","code":"library(bayesRecon)"},{"path":"https://idsia.github.io/bayesRecon/articles/reconciliation_properties.html","id":"data-and-base-forecasts","dir":"Articles","previous_headings":"","what":"Data and base forecasts","title":"Properties of the reconciled distribution via conditioning","text":"release new data set, containing time series counts extreme market events five economic sectors period 2005-2018 (3508 trading days). counts computed considering 29 companies included Euro Stoxx 50 index observing value CDS spread given day exceeds 90-th percentile distribution last trading year. companies divided following sectors: Financial (FIN), Information Communication Technology (ICT), Manufacturing (MFG), Energy (ENG), Trade (TRD). hierarchy composed 5 bottom time series, daily number extreme market events sector, 1 upper time series (sum different sectors). Data stored extr_mkt_events. Figure 1: financial time series hierarchy. also make available extr_mkt_events_basefc base forecasts reconciled. discussed paper, produced using model (Agosto 2022); predictive distributions negative binomial.","code":"# Hierarchy composed by 6 time series: 5 bottom and 1 upper n_b <- 5 n_u <- 1 n <- n_b + n_u     A <- matrix(1, ncol = n_b, nrow = n_u)  # aggregation matrix  # Actual values: actuals <- data.frame(extr_mkt_events)  # convert to data frame # Base forecasts: base_fc <- extr_mkt_events_basefc  N <- nrow(actuals)  # number of days (3508)  # # If you want to run only N reconciliations (instead of 3508): # N <- 200 # actuals <- actuals[1:N,] # base_fc$mu <- base_fc$mu[1:N,]"},{"path":"https://idsia.github.io/bayesRecon/articles/reconciliation_properties.html","id":"reconciliation-via-conditioning","dir":"Articles","previous_headings":"","what":"Reconciliation via conditioning","title":"Properties of the reconciled distribution via conditioning","text":"reconcile base forecasts via conditioning, using importance sampling. use reconc_BUIS function, implements BUIS algorithm (Zambon, Azzimonti, Corani 2024); since one upper time series hierarchy, BUIS algorithm equivalent importance sampling. perform 3508 reconciliations, one day, drawing time 10,000 samples reconciled distribution. use 10,000 samples instead 100,000 (paper) speed computation. day, save empirical mean, median, quantiles reconciled distribution. compute median quantiles negative binomial base forecasts. day time series, compute absolute error, squared error, interval score base reconciled forecasts. compute show skill scores, measure improvement reconciled forecasts base forecasts. skill score symmetric bounded -2 2. table closely matches Table 4 paper. order exactly reproduce paper table, necessary increase number samples drawn reconciled distribution 100,000.","code":"# We need to save the mean and median of the reconciled distribution # in order to compute the squared error and the absolute error: rec_means   <- matrix(NA, ncol = n, nrow = N) rec_medians <- matrix(NA, ncol = n, nrow = N)  # We need to save the lower and upper quantiles of the reconciled distribution # in order to compute the interval score: rec_L <- matrix(NA, ncol = n, nrow = N) rec_U <- matrix(NA, ncol = n, nrow = N) int_cov = 0.9   # use 90% interval          q1 <- (1 - int_cov) / 2 q2 <- (1 + int_cov) / 2  # Set the number of samples to draw from the reconciled distribution: N_samples <- 1e4  start <- Sys.time() for (j in 1:N) {   # Base forecasts:   base_fc_j <- c()      for (i in 1:n) {     base_fc_j[[i]] <- list(size = base_fc$size[[i]], mu = base_fc$mu[[j,i]])   }      # Reconcile via importance sampling:   buis <- reconc_BUIS(A, base_fc_j, \"params\", \"nbinom\",                        num_samples = N_samples, seed = 42)   samples_y <- buis$reconciled_samples      # Save mean, median, and lower and upper quantiles:   rec_means[j,]   <- rowMeans(samples_y)   rec_medians[j,] <- apply(samples_y, 1, median)   rec_L[j,]       <- apply(samples_y, 1, quantile, q1)   rec_U[j,]       <- apply(samples_y, 1, quantile, q2) } stop <- Sys.time() cat(\"Computational time for \", N, \" reconciliations: \",          round(difftime(stop, start, units = \"secs\"), 2), \"s\") #> Computational time for  3508  reconciliations:  57.66 s base_means   <- base_fc$mu base_medians <- matrix(NA, ncol = n, nrow = N) base_L       <- matrix(NA, ncol = n, nrow = N) base_U       <- matrix(NA, ncol = n, nrow = N)  for (i in 1:n) {   base_medians[,i] <- sapply(base_means[,i],                         function(mu) qnbinom(p=0.5, size=base_fc$size[[i]], mu=mu))   base_L[,i]       <- sapply(base_means[,i],                         function(mu) qnbinom(p=q1,  size=base_fc$size[[i]], mu=mu))   base_U[,i]       <- sapply(base_means[,i],                         function(mu) qnbinom(p=q2,  size=base_fc$size[[i]], mu=mu)) } # Compute the squared errors SE_base <- (base_means - actuals)^2 SE_rec  <- (rec_means - actuals)^2  # Compute the absolute errors AE_base <- abs(base_medians - actuals) AE_rec  <- abs(rec_medians - actuals)  # Define the function for the interval score int_score <- function(l, u, actual, int_cov = 0.9) {   is <- (u - l) +   2 / (1-int_cov) * (actual - u) * (actual>u) +   2 / (1-int_cov) * (l - actual) * (l>actual)    return(is) }  # Compute the interval scores IS_base <- mapply(int_score, base_L, base_U, data.matrix(actuals)) IS_base <- matrix(IS_base, nrow = N) IS_rec <- mapply(int_score, rec_L, rec_U, data.matrix(actuals)) IS_rec <- matrix(IS_rec, nrow = N) SS_AE <- (AE_base - AE_rec) / (AE_base + AE_rec) * 2 SS_SE <- (SE_base - SE_rec) / (SE_base + SE_rec) * 2 SS_IS <- (IS_base - IS_rec) / (IS_base + IS_rec) * 2 SS_AE[is.na(SS_AE)] <- 0 SS_SE[is.na(SS_SE)] <- 0 SS_IS[is.na(SS_IS)] <- 0  mean_skill_scores <- c(round(colMeans(SS_IS), 2),                        round(colMeans(SS_SE), 2),                        round(colMeans(SS_AE), 2)) mean_skill_scores <- data.frame(t(matrix(mean_skill_scores, nrow = n))) colnames(mean_skill_scores) <- names(actuals) rownames(mean_skill_scores) <- c(\"Interval score\", \"Squared error\", \"Absolute error\") knitr::kable(mean_skill_scores)"},{"path":"https://idsia.github.io/bayesRecon/articles/reconciliation_properties.html","id":"reconciled-mean-and-variance","dir":"Articles","previous_headings":"","what":"Reconciled mean and variance","title":"Properties of the reconciled distribution via conditioning","text":"now show effects reconciliation mean variance forecast distribution. details, refer Section 3.2 paper. observe two different behaviors reconciled upper mean: can base bottom-mean (combination effect) can lower (concordant-shift effect). show two different days. Finally, show example variance bottom time series increases reconciliation. major difference Gaussian reconciliation, reconciled variance always smaller base variance.","code":"# Now we draw a larger number of samples: N_samples <- 1e5  ### Example of concordant-shift effect j <- 124 base_fc_j <- c()    for (i in 1:n) base_fc_j[[i]] <- list(size = extr_mkt_events_basefc$size[[i]],                                       mu = extr_mkt_events_basefc$mu[[j,i]]) # Reconcile buis <- reconc_BUIS(A, base_fc_j, \"params\", \"nbinom\",                      num_samples = N_samples, seed = 42) samples_y <- buis$reconciled_samples  # The reconciled mean is lower than both the base and bottom-up means: means <- c(round(extr_mkt_events_basefc$mu[[j,1]], 2),            round(sum(extr_mkt_events_basefc$mu[j,2:n]), 2),            round(mean(samples_y[1,]), 2)) col_names <- c(\"Base upper mean\", \"Bottom-up upper mean\", \"Reconciled upper mean\") knitr::kable(matrix(means, nrow=1), col.names = col_names) ### Example of combination effect  j <- 1700 base_fc_j <- c()    for (i in 1:n) base_fc_j[[i]] <- list(size = extr_mkt_events_basefc$size[[i]],                                       mu = extr_mkt_events_basefc$mu[[j,i]]) # Reconcile  buis <- reconc_BUIS(A, base_fc_j, \"params\", \"nbinom\",                      num_samples = N_samples, seed = 42) samples_y <- buis$reconciled_samples  # The reconciled mean is between the base and the bottom-up mean: means <- c(round(extr_mkt_events_basefc$mu[[j,1]], 2),            round(sum(extr_mkt_events_basefc$mu[j,2:n]), 2),            round(mean(samples_y[1,]), 2)) col_names <- c(\"Base upper mean\", \"Bottom-up upper mean\", \"Reconciled upper mean\") knitr::kable(matrix(means, nrow=1), col.names = col_names) j <- 2308 base_fc_j <- c()    for (i in 1:n) base_fc_j[[i]] <- list(size = extr_mkt_events_basefc$size[[i]],                                       mu = extr_mkt_events_basefc$mu[[j,i]]) # Reconcile buis <- reconc_BUIS(A, base_fc_j, \"params\", \"nbinom\", num_samples = N_samples, seed = 42) samples_y <- buis$reconciled_samples  # Compute the variance of the base and reconciled bottom forecasts base_bottom_var <- mapply(function(mu, size) var(rnbinom(n = 1e5, size = size, mu = mu)),                           extr_mkt_events_basefc$mu[j,2:n],                            extr_mkt_events_basefc$size[2:n]) rec_bottom_var <- apply(samples_y[2:n,], MARGIN = 1, var)   # The reconciled variance is greater than the base variance: bottom_var <- rbind(base_bottom_var, rec_bottom_var) rownames(bottom_var) <- c(\"var base\", \"var reconc\") knitr::kable(round(bottom_var, 2))"},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dario Azzimonti. Author, maintainer. Nicolò Rubattu. Author. Lorenzo Zambon. Author. Giorgio Corani. Author.","code":""},{"path":"https://idsia.github.io/bayesRecon/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Azzimonti D, Rubattu N, Zambon L, Corani G (2025). bayesRecon: Probabilistic Reconciliation via Conditioning. R package version 0.3.3, https://github.com/IDSIA/bayesRecon.","code":"@Manual{,   title = {bayesRecon: Probabilistic Reconciliation via Conditioning},   author = {Dario Azzimonti and Nicolò Rubattu and Lorenzo Zambon and Giorgio Corani},   year = {2025},   note = {R package version 0.3.3},   url = {https://github.com/IDSIA/bayesRecon}, }"},{"path":"https://idsia.github.io/bayesRecon/index.html","id":"bayesrecon-bayesian-reconciliation-of-hierarchical-forecasts","dir":"","previous_headings":"","what":"Probabilistic Reconciliation via Conditioning","title":"Probabilistic Reconciliation via Conditioning","text":"package bayesRecon implements several methods probabilistic reconciliation hierarchical time series forecasts. main functions : reconc_gaussian: reconciliation via conditioning multivariate Gaussian base forecasts; done analytically; reconc_BUIS: reconciliation via conditioning probabilistic forecast via importance sampling; recommended option non-Gaussian base forecasts; reconc_MCMC: reconciliation via conditioning discrete probabilistic forecasts via Markov Chain Monte Carlo; reconc_MixCond: reconciliation via conditioning mixed hierarchies, upper forecasts multivariate Gaussian bottom forecasts discrete distributions; reconc_TDcond: reconciliation via top-conditioning mixed hierarchies, upper forecasts multivariate Gaussian bottom forecasts discrete distributions.","code":""},{"path":"https://idsia.github.io/bayesRecon/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting started","title":"Probabilistic Reconciliation via Conditioning","text":"starting point bayesRecon functions vignette “Get Started”. can find documentation Reference section additional vignettes Articles section. Finally short example code provided .","code":""},{"path":"https://idsia.github.io/bayesRecon/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Probabilistic Reconciliation via Conditioning","text":"can install stable version R CRAN can also install development version Github","code":"install.packages(\"bayesRecon\", dependencies = TRUE) # install.packages(\"devtools\") devtools::install_github(\"IDSIA/bayesRecon\", build_vignettes = TRUE, dependencies = TRUE)"},{"path":"https://idsia.github.io/bayesRecon/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"Probabilistic Reconciliation via Conditioning","text":"encounter clear bug, please file minimal reproducible example GitHub.","code":""},{"path":"https://idsia.github.io/bayesRecon/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Probabilistic Reconciliation via Conditioning","text":"Let us consider minimal temporal hierarchy figure, bottom variables two 6-monthly forecasts upper variable yearly forecast. denote variables two semesters year S1,S2,YS_1, S_2, Y respectively.  hierarchy described aggregation matrix , can obtained using function get_reconc_matrices.","code":"library(bayesRecon)  rec_mat <- get_reconc_matrices(agg_levels = c(1, 2), h = 2) A <- rec_mat$A print(A) #>      [,1] [,2] #> [1,]    1    1"},{"path":"https://idsia.github.io/bayesRecon/index.html","id":"example-1-poisson-base-forecasts","dir":"","previous_headings":"Examples","what":"Example 1: Poisson base forecasts","title":"Probabilistic Reconciliation via Conditioning","text":"assume base forecasts Poisson distributed, parameters given λY=9\\lambda_{Y} = 9, λS1=2\\lambda_{S_1} = 2, λS2=4\\lambda_{S_2} = 4. recommend using BUIS algorithm (Zambon et al., 2024) sample reconciled distribution. Since positive incoherence forecasts (λY>λS1+λS2\\lambda_Y > \\lambda_{S_1}+\\lambda_{S_2}), mean bottom reconciled forecast increases. show behavior S1S_1.  blue circles represent probability mass function Poisson parameter λS1\\lambda_{S_1} plotted top histogram reconciled bottom forecasts S1S_1. Note histogram shifted right. Moreover, base bottom forecast assumed independent, operation reconciliation introduced negative correlation S1S_1 S2S_2. can visualize plot shows empirical correlations reconciled samples S1S_1 reconciled samples S2S_2.  also provide function sampling using Markov Chain Monte Carlo (Corani et al., 2023).","code":"lambdaS1 <- 2 lambdaS2 <- 4 lambdaY <- 9 lambdas <- c(lambdaY, lambdaS1, lambdaS2) n_tot = length(lambdas)  base_forecasts = list() for (i in 1:n_tot) {   base_forecasts[[i]] = list(lambda = lambdas[i]) } buis <- reconc_BUIS(   A,   base_forecasts,   in_type = \"params\",   distr = \"poisson\",   num_samples = 100000,   seed = 42 )  samples_buis <- buis$reconciled_samples reconciled_forecast_S1 <- buis$bottom_reconciled_samples[1,] range_forecats <- range(reconciled_forecast_S1) hist(   reconciled_forecast_S1,   breaks = seq(range_forecats[1] - 0.5, range_forecats[2] + 0.5),   freq = F,   xlab = \"S_1\",   ylab = NULL,   main = \"base vs reconciled\" ) points(   seq(range_forecats[1], range_forecats[2]),   stats::dpois(seq(range_forecats[1], range_forecats[2]), lambda =                  lambdaS1),   pch = 16,   col = 4,   cex = 2 ) AA <-   xyTable(buis$bottom_reconciled_samples[1, ],           buis$bottom_reconciled_samples[2, ]) plot(   AA$x ,   AA$y ,   cex = AA$number * 0.001  ,   pch = 16 ,   col = rgb(0, 0, 1, 0.4) ,   xlab = \"S_1\" ,   ylab = \"S_2\" ,   xlim = range(buis$bottom_reconciled_samples[1, ]) ,   ylim = range(buis$bottom_reconciled_samples[2, ]) ) mcmc = reconc_MCMC(   A,   base_forecasts,   distr = \"poisson\",   num_samples = 30000,   seed = 42 )  samples_mcmc <- mcmc$reconciled_samples"},{"path":"https://idsia.github.io/bayesRecon/index.html","id":"example-2-gaussian-base-forecasts","dir":"","previous_headings":"Examples","what":"Example 2: Gaussian base forecasts","title":"Probabilistic Reconciliation via Conditioning","text":"now assume base forecasts Gaussian distributed, parameters given μY=9\\mu_{Y} = 9, μS1=2\\mu_{S_1} = 2, μS2=4\\mu_{S_2} = 4; σY=2\\sigma_{Y} = 2, σS1=2\\sigma_{S_1} = 2, σS2=3\\sigma_{S_2} = 3. use BUIS algorithm sample reconciled distribution: base forecasts Gaussian, reconciled distribution still Gaussian can computed closed form: base means YY, S1S_1, S2S_2 9, 2, 4. reconciled means obtained analytically 7.41, 2.71, 4.71, reconciled means obtained via BUIS 7.41, 2.71, 4.71.","code":"muS1 <- 2 muS2 <- 4 muY <- 9 mus <- c(muY, muS1, muS2)  sigmaS1 <- 2 sigmaS2 <- 2 sigmaY <- 3 sigmas <- c(sigmaY, sigmaS1, sigmaS2)  base_forecasts = list() for (i in 1:n_tot) {   base_forecasts[[i]] = list(mean = mus[[i]], sd = sigmas[[i]]) } buis <- reconc_BUIS(   A,   base_forecasts,   in_type = \"params\",   distr = \"gaussian\",   num_samples = 100000,   seed = 42 ) samples_buis <- buis$reconciled_samples buis_means <- rowMeans(samples_buis) Sigma <- diag(sigmas ^ 2)  #transform into covariance matrix analytic_rec <- reconc_gaussian(A,                                 base_forecasts.mu = mus,                                 base_forecasts.Sigma = Sigma) analytic_means_bottom <- analytic_rec$bottom_reconciled_mean analytic_means_upper <- A %*% analytic_means_bottom analytic_means <- rbind(analytic_means_upper,analytic_means_bottom)"},{"path":"https://idsia.github.io/bayesRecon/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Probabilistic Reconciliation via Conditioning","text":"Corani, G., Azzimonti, D., Augusto, J.P.S.C., Zaffalon, M. (2021). Probabilistic Reconciliation Hierarchical Forecast via Bayes’ Rule. ECML PKDD 2020. Lecture Notes Computer Science, vol 12459. DOI Corani, G., Azzimonti, D., Rubattu, N. (2024). Probabilistic reconciliation count time series. International Journal Forecasting 40 (2), 457-469. DOI Zambon, L., Azzimonti, D. & Corani, G. (2024). Efficient probabilistic reconciliation forecasts real-valued count time series. Statistics Computing 34 (1), 21. DOI Zambon, L., Agosto, ., Giudici, P., Corani, G. (2024). Properties reconciled distributions Gaussian count forecasts. International Journal Forecasting 40 (4), 1438-1448. DOI Zambon, L., Azzimonti, D., Rubattu, N., Corani, G. (2024). Probabilistic reconciliation mixed-type hierarchical time series. Proceedings Fortieth Conference Uncertainty Artificial Intelligence, Proceedings Machine Learning Research 244:4078-4095. Available .","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/M3_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of a time series from the M3 forecasting competition — M3_example","title":"Example of a time series from the M3 forecasting competition — M3_example","text":"monthly time series, M3 forecasting competition (\"N1485\").","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/M3_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of a time series from the M3 forecasting competition — M3_example","text":"","code":"M3_example"},{"path":"https://idsia.github.io/bayesRecon/reference/M3_example.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of a time series from the M3 forecasting competition — M3_example","text":"List time series class ts.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/M3_example.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example of a time series from the M3 forecasting competition — M3_example","text":"https://forecasters.org/resources/time-series-data/m3-competition/","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/M5_CA1_basefc.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of hierarchical forecasts for a store from the M5 competition — M5_CA1_basefc","title":"Example of hierarchical forecasts for a store from the M5 competition — M5_CA1_basefc","text":"dataset contains forecasts hierarchy time series related store CA_1 M5 competition.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/M5_CA1_basefc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of hierarchical forecasts for a store from the M5 competition — M5_CA1_basefc","text":"","code":"M5_CA1_basefc"},{"path":"https://idsia.github.io/bayesRecon/reference/M5_CA1_basefc.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of hierarchical forecasts for a store from the M5 competition — M5_CA1_basefc","text":"list containing: upper: list 11 elements representing aggregation level. element contains: mu, sigma mean standard deviation Gaussian forecast, actual actual value, residuals residuals model used estimate forecasts covariance. lower: list 3049 elements representing forecast item. element contains pmf probability mass function item level forecast, actual actual value. : aggregation matrix . S: S matrix hierarchy. Q_u: scaling factors computing MASE upper forecasts. Q_b: scaling factors computing MASE bottom forecasts.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/M5_CA1_basefc.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example of hierarchical forecasts for a store from the M5 competition — M5_CA1_basefc","text":"Makridakis, Spyros & Spiliotis, Evangelos & Assimakopoulos, Vassilis. (2020). M5 Accuracy competition: Results, findings conclusions. International Journal Forecasting 38(4) 1346-1364. doi:10.1016/j.ijforecast.2021.10.009","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/M5_CA1_basefc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example of hierarchical forecasts for a store from the M5 competition — M5_CA1_basefc","text":"store CA_1 contains 3049 item level time series 11 aggregate time series: Store level aggregation (CA_1) Category level aggregations  (HOBBIES, HOUSEHOLD, FOODS) Department level aggregations (HOBBIES_1, HOBBIES_2, HOUSEHOLD_1, HOUSEHOLD_2, FOODS_1, FOODS_2, FOODS_3) Forecasts generated function forecast model adam package smooth. models bottom time series selected multiplicative Gamma error term (MNN); models upper time series (AXZ) selected Gaussian additive error term, seasonality selected based information criterion. raw data downloaded package m5.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/M5_CA1_basefc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Example of hierarchical forecasts for a store from the M5 competition — M5_CA1_basefc","text":"Joachimiak K (2022). m5: 'M5 Forecasting' Challenges Data. R package version 0.1.1, https://CRAN.R-project.org/package=m5. Makridakis, Spyros & Spiliotis, Evangelos & Assimakopoulos, Vassilis. (2020). M5 Accuracy competition: Results, findings conclusions. International Journal Forecasting 38(4) 1346-1364. doi:10.1016/j.ijforecast.2021.10.009 Svetunkov (2023). smooth: Forecasting Using State Space Models. R package version 4.0.0, https://CRAN.R-project.org/package=smooth.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the mean of the distribution from a PMF object — PMF.get_mean","title":"Get the mean of the distribution from a PMF object — PMF.get_mean","text":"Returns mean PMF specified pmf.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the mean of the distribution from a PMF object — PMF.get_mean","text":"","code":"PMF.get_mean(pmf)"},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the mean of the distribution from a PMF object — PMF.get_mean","text":"pmf PMF object.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the mean of the distribution from a PMF object — PMF.get_mean","text":"numerical value mean distribution.","code":""},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the mean of the distribution from a PMF object — PMF.get_mean","text":"","code":"library(bayesRecon)  # Let's build the pmf of a Binomial distribution with parameters n and p n <- 10 p <- 0.6  pmf_binomial <- apply(matrix(seq(0,10)),MARGIN=1,FUN=function(x) dbinom(x,size=n,prob=p))   # The true mean corresponds to n*p true_mean <- n*p mean_from_PMF <- PMF.get_mean(pmf=pmf_binomial) cat(\"True mean:\", true_mean, \"\\nMean from PMF:\", mean_from_PMF) #> True mean: 6  #> Mean from PMF: 6"},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_quantile.html","id":null,"dir":"Reference","previous_headings":"","what":"Get quantile from a PMF object — PMF.get_quantile","title":"Get quantile from a PMF object — PMF.get_quantile","text":"Returns p quantile PMF specified pmf.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_quantile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get quantile from a PMF object — PMF.get_quantile","text":"","code":"PMF.get_quantile(pmf, p)"},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_quantile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get quantile from a PMF object — PMF.get_quantile","text":"pmf PMF object. p probability required quantile.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_quantile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get quantile from a PMF object — PMF.get_quantile","text":"numeric value quantile.","code":""},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_quantile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get quantile from a PMF object — PMF.get_quantile","text":"","code":"library(bayesRecon)  # Let's build the pmf of a Binomial distribution with parameters n and p n <- 10 p <- 0.6  pmf_binomial <- apply(matrix(seq(0,10)),MARGIN=1,FUN=function(x) dbinom(x,size=n,prob=p))  # The true median is ceiling(n*p) quant_50 <- PMF.get_quantile(pmf=pmf_binomial,p=0.5) cat(\"True median:\", ceiling(n*p), \"\\nMedian from PMF:\", quant_50) #> True median: 6  #> Median from PMF: 6"},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the variance of the distribution from a PMF object — PMF.get_var","title":"Get the variance of the distribution from a PMF object — PMF.get_var","text":"Returns variance PMF specified pmf.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the variance of the distribution from a PMF object — PMF.get_var","text":"","code":"PMF.get_var(pmf)"},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the variance of the distribution from a PMF object — PMF.get_var","text":"pmf PMF object.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the variance of the distribution from a PMF object — PMF.get_var","text":"numerical value variance.","code":""},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.get_var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the variance of the distribution from a PMF object — PMF.get_var","text":"","code":"library(bayesRecon)  # Let's build the pmf of a Binomial distribution with parameters n and p n <- 10 p <- 0.6  pmf_binomial <- apply(matrix(seq(0,10)),MARGIN=1,FUN=function(x) dbinom(x,size=n,prob=p))  # The true variance corresponds to n*p*(1-p) true_var <- n*p*(1-p) var_from_PMF <- PMF.get_var(pmf=pmf_binomial) cat(\"True variance:\", true_var, \"\\nVariance from PMF:\", var_from_PMF) #> True variance: 2.4  #> Variance from PMF: 2.4"},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.sample.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from the distribution given as a PMF object — PMF.sample","title":"Sample from the distribution given as a PMF object — PMF.sample","text":"Samples (replacement) probability distribution specified pmf.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from the distribution given as a PMF object — PMF.sample","text":"","code":"PMF.sample(pmf, N_samples)"},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from the distribution given as a PMF object — PMF.sample","text":"pmf PMF object. N_samples number samples.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from the distribution given as a PMF object — PMF.sample","text":"Samples drawn distribution specified pmf.","code":""},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.sample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample from the distribution given as a PMF object — PMF.sample","text":"","code":"library(bayesRecon)  # Let's build the pmf of a Binomial distribution with parameters n and p n <- 10 p <- 0.6  pmf_binomial <- apply(matrix(seq(0,n)),MARGIN=1,FUN=function(x) dbinom(x,size=n,prob=p))  # Draw samples from the PMF object set.seed(1) samples <- PMF.sample(pmf=pmf_binomial,N_samples = 1e4)  # Plot the histogram computed with the samples and the true value of the PMF hist(samples,breaks=seq(0,n),freq=FALSE) points(seq(0,n)-0.5,pmf_binomial,pch=16)"},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns summary of a PMF object — PMF.summary","title":"Returns summary of a PMF object — PMF.summary","text":"Returns summary (min, max, IQR, median, mean) PMF specified pmf.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns summary of a PMF object — PMF.summary","text":"","code":"PMF.summary(pmf, Ltoll = .TOLL, Rtoll = .RTOLL)"},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns summary of a PMF object — PMF.summary","text":"pmf PMF object. Ltoll used computing min PMF: min smallest value probability greater Ltoll (default: 1e-15) Rtoll used computing max PMF: max largest value probability greater Rtoll (default: 1e-9)","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns summary of a PMF object — PMF.summary","text":"summary data.frame","code":""},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/reference/PMF.summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns summary of a PMF object — PMF.summary","text":"","code":"library(bayesRecon)  # Let's build the pmf of a Binomial distribution with parameters n and p n <- 10 p <- 0.6  pmf_binomial <- apply(matrix(seq(0,10)),MARGIN=1,FUN=function(x) dbinom(x,size=n,prob=p))  # Print the summary of this distribution PMF.summary(pmf=pmf_binomial) #>   Min. 1st Qu. Median Mean 3rd Qu. Max #> 1    0       5      6    6       7  10"},{"path":"https://idsia.github.io/bayesRecon/reference/bayesRecon-package.html","id":null,"dir":"Reference","previous_headings":"","what":"bayesRecon: Probabilistic Reconciliation via Conditioning — bayesRecon-package","title":"bayesRecon: Probabilistic Reconciliation via Conditioning — bayesRecon-package","text":"Provides methods probabilistic reconciliation hierarchical forecasts time series. available methods include analytical Gaussian reconciliation (Corani et al., 2021) doi:10.1007/978-3-030-67664-3_13 , MCMC reconciliation count time series (Corani et al., 2024) doi:10.1016/j.ijforecast.2023.04.003 , Bottom-Importance Sampling (Zambon et al., 2024) doi:10.1007/s11222-023-10343-y , methods reconciliation mixed hierarchies (Mix-Cond TD-cond) (Zambon et al., 2024) https://proceedings.mlr.press/v244/zambon24a.html.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/bayesRecon-package.html","id":"learn-more","dir":"Reference","previous_headings":"","what":"Learn more","title":"bayesRecon: Probabilistic Reconciliation via Conditioning — bayesRecon-package","text":"learn bayesRecon, start vignettes: browseVignettes(package = \"bayesRecon\")","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/bayesRecon-package.html","id":"main-functions","dir":"Reference","previous_headings":"","what":"Main functions","title":"bayesRecon: Probabilistic Reconciliation via Conditioning — bayesRecon-package","text":"package implements reconciliation via conditioning probabilistic forecasts hierarchical time series. main functions : reconc_gaussian(): reconciliation via conditioning multivariate Gaussian base forecasts; done analytically; reconc_BUIS(): reconciliation via conditioning probabilistic forecast via importance sampling; recommended option non-Gaussian base forecasts; reconc_MCMC(): reconciliation via conditioning discrete probabilistic forecasts via Markov Chain Monte Carlo; reconc_MixCond(): reconciliation via conditioning mixed hierarchies, upper forecasts multivariate Gaussian bottom forecasts discrete distributions; reconc_TDcond(): reconciliation via top-conditioning mixed hierarchies, upper forecasts multivariate Gaussian bottom forecasts discrete distributions.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/bayesRecon-package.html","id":"utility-functions","dir":"Reference","previous_headings":"","what":"Utility functions","title":"bayesRecon: Probabilistic Reconciliation via Conditioning — bayesRecon-package","text":"temporal_aggregation(): temporal aggregation given time series object class ts; get_reconc_matrices(): aggregation summing matrices temporal hierarchy time series user-selected list aggregation levels; schaferStrimmer_cov(): computes Schäfer-Strimmer shrinkage estimator covariance matrix; PMF.get_mean(), PMF.get_var(), PMF.get_quantile(), PMF.summary(), PMF.sample(): functions handling PMF objects.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/bayesRecon-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"bayesRecon: Probabilistic Reconciliation via Conditioning — bayesRecon-package","text":"Corani, G., Azzimonti, D., Augusto, J.P.S.C., Zaffalon, M. (2021). Probabilistic Reconciliation Hierarchical Forecast via Bayes' Rule. ECML PKDD 2020. Lecture Notes Computer Science, vol 12459. doi:10.1007/978-3-030-67664-3_13 . Corani, G., Azzimonti, D., Rubattu, N. (2024). Probabilistic reconciliation count time series. International Journal Forecasting 40 (2), 457-469. doi:10.1016/j.ijforecast.2023.04.003 . Zambon, L., Azzimonti, D. & Corani, G. (2024). Efficient probabilistic reconciliation forecasts real-valued count time series. Statistics Computing 34 (1), 21. doi:10.1007/s11222-023-10343-y . Zambon, L., Agosto, ., Giudici, P., Corani, G. (2024). Properties reconciled distributions Gaussian count forecasts. International Journal Forecasting (press). doi:10.1016/j.ijforecast.2023.12.004 . Zambon, L., Azzimonti, D., Rubattu, N., Corani, G. (2024). Probabilistic reconciliation mixed-type hierarchical time series. Proceedings Fortieth Conference Uncertainty Artificial Intelligence, PMLR 244:4078-4095. https://proceedings.mlr.press/v244/zambon24a.html.","code":""},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/reference/bayesRecon-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"bayesRecon: Probabilistic Reconciliation via Conditioning — bayesRecon-package","text":"Maintainer: Dario Azzimonti dario.azzimonti@gmail.com (ORCID) Authors: Nicolò Rubattu nicolo.rubattu@idsia.ch (ORCID) Lorenzo Zambon lorenzo.zambon@idsia.ch (ORCID) Giorgio Corani giorgio.corani@idsia.ch (ORCID)","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/carparts_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of a time series from carparts — carparts_example","title":"Example of a time series from carparts — carparts_example","text":"monthly time series carparts dataset, 51 observations, Jan 1998 - Mar 2002.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/carparts_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of a time series from carparts — carparts_example","text":"","code":"carparts_example"},{"path":"https://idsia.github.io/bayesRecon/reference/carparts_example.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of a time series from carparts — carparts_example","text":"Univariate time series class ts.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/carparts_example.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example of a time series from carparts — carparts_example","text":"Godahewa, R., Bergmeir, C., Webb, G., Hyndman, R.J., & Montero-Manso, P. (2020). Car Parts Dataset (without Missing Values) (Version 2) doi:10.5281/zenodo.4656021","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/carparts_example.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Example of a time series from carparts — carparts_example","text":"Hyndman, R.J., Koehler, .B., Ord, J.K., Snyder, R.D., (2008). Forecasting exponential smoothing: state space approach. Springer Science & Business Media. Godahewa, R., Bergmeir, C., Webb, G., Hyndman, R., & Montero-Manso, P. (2020). Car Parts Dataset (without Missing Values) (Version 2) doi:10.5281/zenodo.4656021","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/extr_mkt_events.html","id":null,"dir":"Reference","previous_headings":"","what":"Extreme market events dataset — extr_mkt_events","title":"Extreme market events dataset — extr_mkt_events","text":"Count time series extreme market events five economic sectors. data refer trading days 2004/12/31 2018/12/19 (3508 trading days total).","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/extr_mkt_events.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extreme market events dataset — extr_mkt_events","text":"","code":"extr_mkt_events"},{"path":"https://idsia.github.io/bayesRecon/reference/extr_mkt_events.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Extreme market events dataset — extr_mkt_events","text":"multivariate time series class ts.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/extr_mkt_events.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Extreme market events dataset — extr_mkt_events","text":"Zambon, L., Agosto, ., Giudici, P., Corani, G. (2024). Properties reconciled distributions Gaussian count forecasts. International Journal Forecasting (press). doi:10.1016/j.ijforecast.2023.12.004 .","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/extr_mkt_events.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extreme market events dataset — extr_mkt_events","text":"counts computed considering 29 companies included Euro Stoxx 50 index observing value CDS spread given day exceeds 90-th percentile distribution last trading year. companies divided following  sectors: Financial (FIN), Information Communication Technology (ICT), Manufacturing (MFG), Energy (ENG), Trade (TRD). 6 time series: 5 bottom time series, corresponding daily counts sector 1 upper time series, sum bottom ()","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/extr_mkt_events.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extreme market events dataset — extr_mkt_events","text":"Zambon, L., Agosto, ., Giudici, P., Corani, G. (2024). Properties reconciled distributions Gaussian count forecasts. International Journal Forecasting (press). doi:10.1016/j.ijforecast.2023.12.004 . Agosto, . (2022). Multivariate Score-Driven Models Count Time Series Assess Financial Contagion. doi:10.2139/ssrn.4119895","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/extr_mkt_events_basefc.html","id":null,"dir":"Reference","previous_headings":"","what":"Base forecasts for the extreme market events dataset — extr_mkt_events_basefc","title":"Base forecasts for the extreme market events dataset — extr_mkt_events_basefc","text":"Base forecasts extr_mkt_events dataset, computed using model Agosto, . (2022). Multivariate Score-Driven Models Count Time Series Assess Financial Contagion. doi:10.2139/ssrn.4119895 .","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/extr_mkt_events_basefc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Base forecasts for the extreme market events dataset — extr_mkt_events_basefc","text":"","code":"extr_mkt_events_basefc"},{"path":"https://idsia.github.io/bayesRecon/reference/extr_mkt_events_basefc.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Base forecasts for the extreme market events dataset — extr_mkt_events_basefc","text":"list extr_mkt_events_basefc containing extr_mkt_events_basefc$mu data frame base forecast means, day extr_mkt_events_basefc$size data frame static base forecast size parameters","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/extr_mkt_events_basefc.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Base forecasts for the extreme market events dataset — extr_mkt_events_basefc","text":"Agosto, . (2022). Multivariate Score-Driven Models Count Time Series Assess Financial Contagion. doi:10.2139/ssrn.4119895","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/extr_mkt_events_basefc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Base forecasts for the extreme market events dataset — extr_mkt_events_basefc","text":"predictive distribution bottom time series multivariate negative binomial static vector dispersion parameters time-varying vector location parameters following score-driven dynamics. base forecasts upper time series computed using univariate version model. -sample forecasts: training instant, computed time t+1 conditioning counts observed time t.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/extr_mkt_events_basefc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Base forecasts for the extreme market events dataset — extr_mkt_events_basefc","text":"Agosto, . (2022). Multivariate Score-Driven Models Count Time Series Assess Financial Contagion. doi:10.2139/ssrn.4119895 Zambon, L., Agosto, ., Giudici, P., Corani, G. (2024). Properties reconciled distributions Gaussian count forecasts. International Journal Forecasting (press). doi:10.1016/j.ijforecast.2023.12.004 .","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/get_reconc_matrices.html","id":null,"dir":"Reference","previous_headings":"","what":"Build hierarchy matrices — get_reconc_matrices","title":"Build hierarchy matrices — get_reconc_matrices","text":"Creates aggregation summing matrices temporal hierarchy time series user-selected list aggregation levels.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/get_reconc_matrices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build hierarchy matrices — get_reconc_matrices","text":"","code":"get_reconc_matrices(agg_levels, h)"},{"path":"https://idsia.github.io/bayesRecon/reference/get_reconc_matrices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build hierarchy matrices — get_reconc_matrices","text":"agg_levels user-selected list aggregation levels. h number steps ahead bottom level forecasts.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/get_reconc_matrices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build hierarchy matrices — get_reconc_matrices","text":"list containing named elements: aggregation matrix; S summing matrix.","code":""},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/reference/get_reconc_matrices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build hierarchy matrices — get_reconc_matrices","text":"","code":"library(bayesRecon)  #Create monthly hierarchy agg_levels <- c(1,2,3,4,6,12) h <- 12 rec_mat <- get_reconc_matrices(agg_levels, h) S <- rec_mat$S A <- rec_mat$A"},{"path":"https://idsia.github.io/bayesRecon/reference/infantMortality.html","id":null,"dir":"Reference","previous_headings":"","what":"Infant Mortality grouped time series dataset — infantMortality","title":"Infant Mortality grouped time series dataset — infantMortality","text":"yearly grouped time series dataset, 1901 2003, infant mortality counts (deaths) Australia; disaggregated state (see ), sex (male female).","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/infantMortality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infant Mortality grouped time series dataset — infantMortality","text":"","code":"infantMortality"},{"path":"https://idsia.github.io/bayesRecon/reference/infantMortality.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Infant Mortality grouped time series dataset — infantMortality","text":"List time series class ts.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/infantMortality.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Infant Mortality grouped time series dataset — infantMortality","text":"hts package CRAN","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/infantMortality.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Infant Mortality grouped time series dataset — infantMortality","text":"States: New South Wales (NSW), Victoria (VIC), Queensland (QLD), South Australia (SA), Western Australia (WA), Northern Territory (NT), Australian Capital Territory (ACT), Tasmania (TAS).","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/infantMortality.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Infant Mortality grouped time series dataset — infantMortality","text":"Hyndman, R.J., Ahmed, R.., Athanasopoulos, G., Shang, H.L. (2011). Optimal combination forecasts hierarchical time series. Computational Statistics Data Analysis, 55(9), 2579-2589.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_BUIS.html","id":null,"dir":"Reference","previous_headings":"","what":"BUIS for Probabilistic Reconciliation of forecasts via conditioning — reconc_BUIS","title":"BUIS for Probabilistic Reconciliation of forecasts via conditioning — reconc_BUIS","text":"Uses Bottom-Importance Sampling algorithm draw samples reconciled forecast distribution, obtained via conditioning.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_BUIS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BUIS for Probabilistic Reconciliation of forecasts via conditioning — reconc_BUIS","text":"","code":"reconc_BUIS(   A,   base_forecasts,   in_type,   distr,   num_samples = 20000,   suppress_warnings = FALSE,   seed = NULL )"},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_BUIS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BUIS for Probabilistic Reconciliation of forecasts via conditioning — reconc_BUIS","text":"aggregation matrix (n_upper x n_bottom). base_forecasts list containing base_forecasts, see details. in_type string list length n_upper + n_bottom. list -th element string two possible values: 'samples' -th base forecasts form samples; 'params'  -th base forecasts form estimated parameters. in_type string assumed base forecasts type. distr string list length n_upper + n_bottom describing type base forecasts. list -th element string two possible values: 'continuous' 'discrete' in_type[[]]='samples'; 'gaussian', 'poisson' 'nbinom' in_type[[]]='params'. distr string assumed distributions type. num_samples Number samples drawn reconciled distribution. ignored bottom_in_type='samples'; case, number reconciled samples equal number samples base forecasts. suppress_warnings Logical. TRUE, warnings effective sample size triggered. FALSE, warnings generated. Default FALSE. See Details. seed Seed reproducibility.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_BUIS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"BUIS for Probabilistic Reconciliation of forecasts via conditioning — reconc_BUIS","text":"list containing reconciled forecasts. list following named elements: bottom_reconciled_samples: matrix (n_bottom x num_samples) containing reconciled samples bottom time series; upper_reconciled_samples: matrix (n_upper x num_samples) containing reconciled samples upper time series; reconciled_samples: matrix (n x num_samples) containing reconciled samples time series.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_BUIS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"BUIS for Probabilistic Reconciliation of forecasts via conditioning — reconc_BUIS","text":"parameter base_forecast list containing n = n_upper + n_bottom elements. first n_upper elements list upper base forecasts, order given rows . elements n_upper+1 end list bottom base forecasts, order given columns . -th element depends values in_type[[]] distr[[]]. in_type[[]]='samples', base_forecast[[]] vector containing samples base forecast distribution. in_type[[]]='params', base_forecast[[]] list containing estimated: mean sd Gaussian base forecast distr[[]]='gaussian', see Normal; lambda Poisson base forecast distr[[]]='poisson', see Poisson; size prob (mu) negative binomial base forecast distr[[]]='nbinom', see NegBinomial. See description parameters in_type distr details. Warnings triggered Importance Sampling step : weights zeros, upper ignored reconciliation; effective sample size < 200; effective sample size < 1% sample size (num_samples in_type 'params' size base forecast in_type 'samples'). Note warnings indication base forecasts might issues. Please check base forecasts case warnings.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_BUIS.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"BUIS for Probabilistic Reconciliation of forecasts via conditioning — reconc_BUIS","text":"Zambon, L., Azzimonti, D. & Corani, G. (2024). Efficient probabilistic reconciliation forecasts real-valued count time series. Statistics Computing 34 (1), 21. doi:10.1007/s11222-023-10343-y .","code":""},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_BUIS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"BUIS for Probabilistic Reconciliation of forecasts via conditioning — reconc_BUIS","text":"","code":"library(bayesRecon)  # Create a minimal hierarchy with 2 bottom and 1 upper variable rec_mat <- get_reconc_matrices(agg_levels=c(1,2), h=2) A <- rec_mat$A S <- rec_mat$S   #1) Gaussian base forecasts  #Set the parameters of the Gaussian base forecast distributions mu1 <- 2 mu2 <- 4 muY <- 9 mus <- c(muY,mu1,mu2)  sigma1 <- 2 sigma2 <- 2 sigmaY <- 3 sigmas <- c(sigmaY,sigma1,sigma2)  base_forecasts = list() for (i in 1:length(mus)) { base_forecasts[[i]] = list(mean = mus[[i]], sd = sigmas[[i]]) }   #Sample from the reconciled forecast distribution using the BUIS algorithm buis <- reconc_BUIS(A, base_forecasts, in_type=\"params\",                  distr=\"gaussian\", num_samples=100000, seed=42)  samples_buis <- buis$reconciled_samples  #In the Gaussian case, the reconciled distribution is still Gaussian and can be #computed in closed form Sigma <- diag(sigmas^2)  #transform into covariance matrix analytic_rec <- reconc_gaussian(A, base_forecasts.mu = mus,                                 base_forecasts.Sigma = Sigma)  #Compare the reconciled means obtained analytically and via BUIS print(c(S %*% analytic_rec$bottom_reconciled_mean)) #> [1] 7.411765 2.705882 4.705882 print(rowMeans(samples_buis)) #> [1] 7.413147 2.707427 4.705720   #2) Poisson base forecasts  #Set the parameters of the Poisson base forecast distributions lambda1 <- 2 lambda2 <- 4 lambdaY <- 9 lambdas <- c(lambdaY,lambda1,lambda2)  base_forecasts <- list() for (i in 1:length(lambdas)) {  base_forecasts[[i]] = list(lambda = lambdas[i]) }  #Sample from the reconciled forecast distribution using the BUIS algorithm buis <- reconc_BUIS(A, base_forecasts, in_type=\"params\",                           distr=\"poisson\", num_samples=100000, seed=42) samples_buis <- buis$reconciled_samples  #Print the reconciled means print(rowMeans(samples_buis)) #> [1] 7.09171 2.36542 4.72629"},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_MCMC.html","id":null,"dir":"Reference","previous_headings":"","what":"MCMC for Probabilistic Reconciliation of forecasts via conditioning — reconc_MCMC","title":"MCMC for Probabilistic Reconciliation of forecasts via conditioning — reconc_MCMC","text":"Uses Markov Chain Monte Carlo algorithm draw samples reconciled forecast distribution, obtained via conditioning. bare-bones implementation Metropolis-Hastings algorithm, suggest usage tools check convergence. function works Poisson Negative Binomial base forecasts. function reconc_BUIS() generally faster hierarchies.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_MCMC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MCMC for Probabilistic Reconciliation of forecasts via conditioning — reconc_MCMC","text":"","code":"reconc_MCMC(   A,   base_forecasts,   distr,   num_samples = 10000,   tuning_int = 100,   init_scale = 1,   burn_in = 1000,   seed = NULL )"},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_MCMC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MCMC for Probabilistic Reconciliation of forecasts via conditioning — reconc_MCMC","text":"aggregation matrix (n_upper x n_bottom). base_forecasts list parameters base forecast distributions, see details. distr string describing type predictive distribution. num_samples number samples draw using MCMC. tuning_int number iterations scale updates proposal. init_scale initial scale proposal. burn_in number initial samples discarded. seed seed reproducibility.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_MCMC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MCMC for Probabilistic Reconciliation of forecasts via conditioning — reconc_MCMC","text":"list containing reconciled forecasts. list following named elements: bottom_reconciled_samples: matrix (n_bottom x num_samples) containing reconciled samples bottom time series; upper_reconciled_samples: matrix (n_upper x num_samples) containing reconciled samples upper time series; reconciled_samples: matrix (n x num_samples) containing reconciled samples time series.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_MCMC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"MCMC for Probabilistic Reconciliation of forecasts via conditioning — reconc_MCMC","text":"parameter base_forecast list containing n = n_upper + n_bottom elements. element list containing estimated: mean sd Gaussian base forecast, see Normal, distr='gaussian'; lambda Poisson base forecast, see Poisson, distr='poisson'; size prob (mu) negative binomial base forecast, see NegBinomial, distr='nbinom'. first n_upper elements list upper base forecasts, order given rows . elements n_upper+1 end list bottom base forecasts, order given columns .","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_MCMC.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"MCMC for Probabilistic Reconciliation of forecasts via conditioning — reconc_MCMC","text":"Corani, G., Azzimonti, D., Rubattu, N. (2024). Probabilistic reconciliation count time series. International Journal Forecasting 40 (2), 457-469. doi:10.1016/j.ijforecast.2023.04.003 .","code":""},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_MCMC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"MCMC for Probabilistic Reconciliation of forecasts via conditioning — reconc_MCMC","text":"","code":"library(bayesRecon)  # Create a minimal hierarchy with 2 bottom and 1 upper variable rec_mat <- get_reconc_matrices(agg_levels=c(1,2), h=2) A <- rec_mat$A  #Set the parameters of the Poisson base forecast distributions lambda1 <- 2 lambda2 <- 4 lambdaY <- 9 lambdas <- c(lambdaY,lambda1,lambda2)  base_forecasts = list() for (i in 1:length(lambdas)) {  base_forecasts[[i]] = list(lambda = lambdas[i]) }  #Sample from the reconciled forecast distribution using MCMC mcmc = reconc_MCMC(A, base_forecasts, distr = \"poisson\",                   num_samples = 30000, seed = 42) samples_mcmc <- mcmc$reconciled_samples  #Compare the reconciled means with those obtained via BUIS buis = reconc_BUIS(A, base_forecasts, in_type=\"params\",                    distr=\"poisson\", num_samples=100000, seed=42) samples_buis <- buis$reconciled_samples  print(rowMeans(samples_mcmc)) #> [1] 7.091733 2.363633 4.728100 print(rowMeans(samples_buis)) #> [1] 7.09171 2.36542 4.72629"},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_MixCond.html","id":null,"dir":"Reference","previous_headings":"","what":"Probabilistic forecast reconciliation of mixed hierarchies via conditioning — reconc_MixCond","title":"Probabilistic forecast reconciliation of mixed hierarchies via conditioning — reconc_MixCond","text":"Uses importance sampling draw samples reconciled forecast distribution, obtained via conditioning, case mixed hierarchy.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_MixCond.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probabilistic forecast reconciliation of mixed hierarchies via conditioning — reconc_MixCond","text":"","code":"reconc_MixCond(   A,   fc_bottom,   fc_upper,   bottom_in_type = \"pmf\",   distr = NULL,   num_samples = 20000,   return_type = \"pmf\",   suppress_warnings = FALSE,   seed = NULL )"},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_MixCond.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probabilistic forecast reconciliation of mixed hierarchies via conditioning — reconc_MixCond","text":"Aggregation matrix (n_upper x n_bottom). fc_bottom list containing bottom base forecasts, see details. fc_upper list containing upper base forecasts, see details. bottom_in_type string three possible values: 'pmf' bottom base forecasts form pmf, see details; 'samples' bottom base forecasts form samples; 'params'  bottom base forecasts form estimated parameters. distr string describing type bottom base forecasts ('poisson' 'nbinom'). used bottom_in_type='params'. num_samples Number samples drawn reconciled distribution. ignored bottom_in_type='samples'; case, number reconciled samples equal number samples base forecasts. return_type return type reconciled distributions. string three possible values: 'pmf' returns list containing reconciled marginal pmf objects; 'samples' returns list containing reconciled multivariate samples; '' returns list pmf objects samples. suppress_warnings Logical. TRUE, warnings samples triggered. FALSE, warnings generated. Default FALSE. See Details. seed Seed reproducibility.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_MixCond.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probabilistic forecast reconciliation of mixed hierarchies via conditioning — reconc_MixCond","text":"list containing reconciled forecasts. list following named elements: bottom_reconciled: list containing pmf, samples (matrix n_bottom x num_samples) , depending value return_type; upper_reconciled: list containing pmf, samples (matrix n_upper x num_samples) , depending value return_type.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_MixCond.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Probabilistic forecast reconciliation of mixed hierarchies via conditioning — reconc_MixCond","text":"base bottom forecasts fc_bottom must list length n_bottom, element either PMF object (see details ), bottom_in_type='pmf'; vector samples, bottom_in_type='samples'; list parameters, bottom_in_type='params': lambda Poisson base forecast distr='poisson', see Poisson; size prob (mu) negative binomial base forecast distr='nbinom', see NegBinomial. base upper forecasts fc_upper must list containing parameters multivariate Gaussian distribution upper forecasts. list must contain named elements mu (vector length n_upper) Sigma (n_upper x n_upper matrix). order upper bottom base forecasts must match order (respectively) rows columns . PMF object numerical vector containing probability mass function discrete distribution. element corresponds probability integers 0 last value support. See also PMF.get_mean, PMF.get_var, PMF.sample, PMF.get_quantile, PMF.summary functions handle PMF objects. Warnings triggered Importance Sampling step : weights zeros, upper forecast ignored reconciliation; effective sample size < 200; effective sample size < 1% sample size. Note warnings indication base forecasts might issues. Please check base forecasts case warnings.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_MixCond.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Probabilistic forecast reconciliation of mixed hierarchies via conditioning — reconc_MixCond","text":"Zambon, L., Azzimonti, D., Rubattu, N., Corani, G. (2024). Probabilistic reconciliation mixed-type hierarchical time series. Proceedings Fortieth Conference Uncertainty Artificial Intelligence, PMLR 244:4078-4095. https://proceedings.mlr.press/v244/zambon24a.html.","code":""},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_MixCond.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Probabilistic forecast reconciliation of mixed hierarchies via conditioning — reconc_MixCond","text":"","code":"library(bayesRecon)  # Consider a simple hierarchy with two bottom and one upper A <- matrix(c(1,1),nrow=1) # The bottom forecasts are Poisson with lambda=15 lambda <- 15 n_tot <- 60 fc_bottom <- list() fc_bottom[[1]] <- apply(matrix(seq(0,n_tot)),MARGIN=1,FUN=function(x) dpois(x,lambda=lambda)) fc_bottom[[2]] <- apply(matrix(seq(0,n_tot)),MARGIN=1,FUN=function(x) dpois(x,lambda=lambda))  # The upper forecast is a Normal with mean 40 and std 5 fc_upper<- list(mu=40, Sigma=matrix(5^2))  # We can reconcile with reconc_MixCond res.mixCond <- reconc_MixCond(A, fc_bottom, fc_upper)  # Note that the bottom distributions are slightly shifted to the right PMF.summary(res.mixCond$bottom_reconciled$pmf[[1]]) #>   Min. 1st Qu. Median    Mean 3rd Qu. Max #> 1    0      15     18 17.7466      20  32 PMF.summary(fc_bottom[[1]]) #>   Min. 1st Qu. Median Mean 3rd Qu. Max #> 1    0      12     15   15      18  43  PMF.summary(res.mixCond$bottom_reconciled$pmf[[2]]) #>   Min. 1st Qu. Median    Mean 3rd Qu. Max #> 1    0      15     18 17.7485      20  31 PMF.summary(fc_bottom[[2]]) #>   Min. 1st Qu. Median Mean 3rd Qu. Max #> 1    0      12     15   15      18  43  # The upper distribution is slightly shifted to the left PMF.summary(res.mixCond$upper_reconciled$pmf[[1]]) #>   Min. 1st Qu. Median    Mean 3rd Qu. Max #> 1    0      33     35 35.4951      38  51 PMF.get_var(res.mixCond$upper_reconciled$pmf[[1]]) #>          [,1] #> [1,] 14.33569"},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_TDcond.html","id":null,"dir":"Reference","previous_headings":"","what":"Probabilistic forecast reconciliation of mixed hierarchies via top-down conditioning — reconc_TDcond","title":"Probabilistic forecast reconciliation of mixed hierarchies via top-down conditioning — reconc_TDcond","text":"Uses top-conditioning algorithm draw samples reconciled forecast distribution. Reconciliation performed two steps: first, upper base forecasts reconciled via conditioning, using hierarchical constraints upper variables; , bottom distributions updated via probabilistic top-procedure.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_TDcond.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probabilistic forecast reconciliation of mixed hierarchies via top-down conditioning — reconc_TDcond","text":"","code":"reconc_TDcond(   A,   fc_bottom,   fc_upper,   bottom_in_type = \"pmf\",   distr = NULL,   num_samples = 20000,   return_type = \"pmf\",   suppress_warnings = FALSE,   seed = NULL )"},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_TDcond.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probabilistic forecast reconciliation of mixed hierarchies via top-down conditioning — reconc_TDcond","text":"aggregation matrix (n_upper x n_bottom). fc_bottom list containing bottom base forecasts, see details. fc_upper list containing upper base forecasts, see details. bottom_in_type string three possible values: 'pmf' bottom base forecasts form pmf, see details; 'samples' bottom base forecasts form samples; 'params'  bottom base forecasts form estimated parameters. distr string describing type bottom base forecasts ('poisson' 'nbinom'). used bottom_in_type=='params'. num_samples Number samples drawn reconciled distribution. ignored bottom_in_type='samples'; case, number reconciled samples equal number samples base forecasts. return_type return type reconciled distributions. string three possible values: 'pmf' returns list containing reconciled marginal pmf objects; 'samples' returns list containing reconciled multivariate samples; '' returns list pmf objects samples. suppress_warnings Logical. TRUE, warnings samples triggered. FALSE, warnings generated. Default FALSE. See Details. seed Seed reproducibility.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_TDcond.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probabilistic forecast reconciliation of mixed hierarchies via top-down conditioning — reconc_TDcond","text":"list containing reconciled forecasts. list following named elements: bottom_reconciled: list containing pmf, samples (matrix n_bottom x num_samples) , depending value return_type; upper_reconciled: list containing pmf, samples (matrix n_upper x num_samples) , depending value return_type.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_TDcond.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Probabilistic forecast reconciliation of mixed hierarchies via top-down conditioning — reconc_TDcond","text":"base bottom forecasts fc_bottom must list length n_bottom, element either PMF object (see details ), bottom_in_type='pmf'; vector samples, bottom_in_type='samples'; list parameters, bottom_in_type='params': lambda Poisson base forecast distr='poisson', see Poisson; size prob (mu) negative binomial base forecast distr='nbinom', see NegBinomial. base upper forecasts fc_upper must list containing parameters multivariate Gaussian distribution upper forecasts. list must contain named elements mu (vector length n_upper) Sigma (n_upper x n_upper matrix). order upper bottom base forecasts must match order (respectively) rows columns . PMF object numerical vector containing probability mass function discrete distribution. element corresponds probability integers 0 last value support. See also PMF.get_mean, PMF.get_var, PMF.sample, PMF.get_quantile, PMF.summary functions handle PMF objects. reconciled upper samples lie outside support bottom-distribution, samples discarded warning triggered. warning reports percentage samples kept.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_TDcond.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Probabilistic forecast reconciliation of mixed hierarchies via top-down conditioning — reconc_TDcond","text":"Zambon, L., Azzimonti, D., Rubattu, N., Corani, G. (2024). Probabilistic reconciliation mixed-type hierarchical time series. Proceedings Fortieth Conference Uncertainty Artificial Intelligence, PMLR 244:4078-4095. https://proceedings.mlr.press/v244/zambon24a.html.","code":""},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_TDcond.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Probabilistic forecast reconciliation of mixed hierarchies via top-down conditioning — reconc_TDcond","text":"","code":"library(bayesRecon)  # Consider a simple hierarchy with two bottom and one upper A <- matrix(c(1,1),nrow=1) # The bottom forecasts are Poisson with lambda=15 lambda <- 15 n_tot <- 60 fc_bottom <- list() fc_bottom[[1]] <- apply(matrix(seq(0,n_tot)),MARGIN=1,FUN=function(x) dpois(x,lambda=lambda)) fc_bottom[[2]] <- apply(matrix(seq(0,n_tot)),MARGIN=1,FUN=function(x) dpois(x,lambda=lambda))  # The upper forecast is a Normal with mean 40 and std 5 fc_upper<- list(mu=40, Sigma=matrix(c(5^2)))  # We can reconcile with reconc_TDcond res.TDcond <- reconc_TDcond(A, fc_bottom, fc_upper)  # Note that the bottom distributions are shifted to the right PMF.summary(res.TDcond$bottom_reconciled$pmf[[1]]) #>   Min. 1st Qu. Median     Mean 3rd Qu. Max #> 1    0      17     20 19.98895      23  37 PMF.summary(fc_bottom[[1]]) #>   Min. 1st Qu. Median Mean 3rd Qu. Max #> 1    0      12     15   15      18  43  PMF.summary(res.TDcond$bottom_reconciled$pmf[[2]]) #>   Min. 1st Qu. Median     Mean 3rd Qu. Max #> 1    0      17     20 19.99945      23  37 PMF.summary(fc_bottom[[2]]) #>   Min. 1st Qu. Median Mean 3rd Qu. Max #> 1    0      12     15   15      18  43  # The upper distribution remains similar PMF.summary(res.TDcond$upper_reconciled$pmf[[1]]) #>   Min. 1st Qu. Median    Mean 3rd Qu. Max #> 1    0      37     40 39.9884      43  60 PMF.get_var(res.TDcond$upper_reconciled$pmf[[1]]) #>          [,1] #> [1,] 24.78059  ## Example 2: reconciliation with unbalanced hierarchy # We consider the example in Fig. 9 of Zambon et al. (2024).  # The hierarchy has 5 bottoms and 3 uppers A <- matrix(c(1,1,1,1,1,               1,1,0,0,0,               0,0,1,1,0),nrow=3,byrow = TRUE) # Note that the 5th bottom only appears in the highest level, this is an unbalanced hierarchy.  n_upper  = nrow(A) n_bottom = ncol(A)  # The bottom forecasts are Poisson with lambda=15 lambda <- 15 n_tot <- 60 fc_bottom <- list() for(i in seq(n_bottom)){   fc_bottom[[i]] <- apply(matrix(seq(0,n_tot)),MARGIN=1,FUN=function(x) dpois(x,lambda=lambda)) }  # The upper forecasts are a multivariate Gaussian mu = c(75, 30, 30) Sigma = matrix(c(5^2,5,5,                  5, 10, 0,                  5, 0,10), nrow=3, byrow = TRUE)                   fc_upper<- list(mu=mu, Sigma=Sigma) if (FALSE) { # \\dontrun{ # If we reconcile with reconc_TDcond it won't work res.TDcond <- reconc_TDcond(A, fc_bottom, fc_upper) } # }  # We can balance the hierarchy with by duplicating the node b5 # In practice this means:  # i) consider the time series observations for b5 as the upper u4, # ii) fit the multivariate ts model for u1, u2, u3, u4.   # In this example we simply assume that the forecast for u1-u4 is  # Gaussian with the mean and variance of u4 given by the parameters in b5.  mean_b5 <- lambda var_b5  <- lambda mu = c(75, 30, 30,mean_b5) Sigma = matrix(c(5^2,5,5,5,                  5, 10, 0, 0,                  5, 0, 10, 0,                  5, 0,  0, var_b5), nrow=4, byrow = TRUE) fc_upper<- list(mu=mu, Sigma=Sigma)  # We also need to update the aggregation matrix A <- matrix(c(1,1,1,1,1,               1,1,0,0,0,               0,0,1,1,0,               0,0,0,0,1),nrow=4,byrow = TRUE)                # We can now reconcile with TDcond res.TDcond <- reconc_TDcond(A, fc_bottom, fc_upper)  # Note that the reconciled distribution of b5 and u4 are identical,  # keep this in mind when using the results of your reconciliation! max(abs(res.TDcond$bottom_reconciled$pmf[[5]]- res.TDcond$upper_reconciled$pmf[[4]])) #> [1] 0"},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_gaussian.html","id":null,"dir":"Reference","previous_headings":"","what":"Analytical reconciliation of Gaussian base forecasts — reconc_gaussian","title":"Analytical reconciliation of Gaussian base forecasts — reconc_gaussian","text":"Closed form computation reconciled forecasts case Gaussian base forecasts.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_gaussian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analytical reconciliation of Gaussian base forecasts — reconc_gaussian","text":"","code":"reconc_gaussian(A, base_forecasts.mu, base_forecasts.Sigma)"},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_gaussian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analytical reconciliation of Gaussian base forecasts — reconc_gaussian","text":"aggregation matrix (n_upper x n_bottom). base_forecasts.mu vector containing means base forecasts. base_forecasts.Sigma matrix containing covariance matrix base forecasts.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_gaussian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analytical reconciliation of Gaussian base forecasts — reconc_gaussian","text":"list containing bottom reconciled forecasts. list following named elements: bottom_reconciled_mean: reconciled mean bottom forecasts; bottom_reconciled_covariance: reconciled covariance bottom forecasts.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_gaussian.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analytical reconciliation of Gaussian base forecasts — reconc_gaussian","text":"vector means base forecasts order must : first upper, bottom; order within uppers given rows , order within bottoms columns . order rows covariance matrix base forecasts . function returns reconciled parameters bottom variables. reconciled upper parameters reconciled samples entire hierarchy can obtained reconciled bottom parameters. See example section.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_gaussian.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Analytical reconciliation of Gaussian base forecasts — reconc_gaussian","text":"Corani, G., Azzimonti, D., Augusto, J.P.S.C., Zaffalon, M. (2021). Probabilistic Reconciliation Hierarchical Forecast via Bayes' Rule. ECML PKDD 2020. Lecture Notes Computer Science, vol 12459. doi:10.1007/978-3-030-67664-3_13 . Zambon, L., Agosto, ., Giudici, P., Corani, G. (2024). Properties reconciled distributions Gaussian count forecasts. International Journal Forecasting (press). doi:10.1016/j.ijforecast.2023.12.004 .","code":""},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/reference/reconc_gaussian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analytical reconciliation of Gaussian base forecasts — reconc_gaussian","text":"","code":"library(bayesRecon)  # Create a minimal hierarchy with 2 bottom and 1 upper variable A <- get_reconc_matrices(agg_levels=c(1,2), h=2)$A  #Set the parameters of the Gaussian base forecast distributions mu1 <- 2 mu2 <- 4 muY <- 9 mus <- c(muY,mu1,mu2)  sigma1 <- 2 sigma2 <- 2 sigmaY <- 3 sigmas <- c(sigmaY,sigma1,sigma2)  Sigma <- diag(sigmas^2)  # need to transform into covariance matrix analytic_rec <- reconc_gaussian(A, base_forecasts.mu = mus,                                base_forecasts.Sigma = Sigma)  bottom_mu_reconc <- analytic_rec$bottom_reconciled_mean bottom_Sigma_reconc <- analytic_rec$bottom_reconciled_covariance  # Obtain reconciled mu and Sigma for the upper variable upper_mu_reconc <- A %*% bottom_mu_reconc upper_Sigma_reconc <- A %*% bottom_Sigma_reconc %*% t(A)  # Obtain reconciled mu and Sigma for the entire hierarchy S <- rbind(A, diag(2))  # first, get summing matrix S Y_mu_reconc <- S %*% bottom_mu_reconc Y_Sigma_reconc <- S %*% bottom_Sigma_reconc %*% t(S)  # note that this is a singular matrix  # Obtain reconciled samples for the entire hierarchy: # i.e., sample from the reconciled bottoms and multiply by S chol_decomp = chol(bottom_Sigma_reconc) # Compute the Cholesky Decomposition Z = matrix(stats::rnorm(n = 2000), nrow = 2) # Sample from standard normal B = t(chol_decomp) %*% Z + matrix(rep(bottom_mu_reconc, 1000), nrow=2) # Apply the transformation  U = S %*% B Y_reconc = rbind(U, B)"},{"path":"https://idsia.github.io/bayesRecon/reference/schaferStrimmer_cov.html","id":null,"dir":"Reference","previous_headings":"","what":"Schäfer Strimmer covariance shrinkage — schaferStrimmer_cov","title":"Schäfer Strimmer covariance shrinkage — schaferStrimmer_cov","text":"Computes Schäfer Strimmer shrinkage estimator covariance matrix matrix samples.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/schaferStrimmer_cov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Schäfer Strimmer covariance shrinkage — schaferStrimmer_cov","text":"","code":"schaferStrimmer_cov(x)"},{"path":"https://idsia.github.io/bayesRecon/reference/schaferStrimmer_cov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Schäfer Strimmer covariance shrinkage — schaferStrimmer_cov","text":"x matrix samples dimensions nxp (n samples, p dimensions).","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/schaferStrimmer_cov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Schäfer Strimmer covariance shrinkage — schaferStrimmer_cov","text":"list containing shrinkage estimator optimal lambda. list following named elements: shrink_cov: shrinked covariance matrix (p x p); lambda_star: optimal lambda shrinkage;","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/schaferStrimmer_cov.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Schäfer Strimmer covariance shrinkage — schaferStrimmer_cov","text":"function computes shrinkage diagonal covariance unequal variances. Note use estimators \\(S = X X^T/n\\) \\(T = diag(S)\\) internally use correlation matrix place covariance compute optimal shrinkage factor.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/schaferStrimmer_cov.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Schäfer Strimmer covariance shrinkage — schaferStrimmer_cov","text":"Schäfer, Juliane, Korbinian Strimmer. (2005). Shrinkage Approach Large-Scale Covariance Matrix Estimation Implications Functional Genomics. Statistical Applications Genetics Molecular Biology 4: Article32. doi:10.2202/1544-6115.1175 .","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/schaferStrimmer_cov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Schäfer Strimmer covariance shrinkage — schaferStrimmer_cov","text":"","code":"# Generate some multivariate normal samples # Parameters nSamples <- 200 pTrue <- 2  # True moments trueSigma <- matrix(c(3,2,2,2), nrow=2) chol_trueSigma <- chol(trueSigma) trueMean <- c(0,0)   # Generate samples set.seed(42) x <- replicate(nSamples, trueMean) +        t(chol_trueSigma)%*%matrix(stats::rnorm(pTrue*nSamples),                                  nrow = pTrue, ncol = nSamples) x <- t(x)  res_shrinkage <- schaferStrimmer_cov(x) res_shrinkage$lambda_star # should be 0.01287923 #> [1] 0.01287923"},{"path":"https://idsia.github.io/bayesRecon/reference/temporal_aggregation.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal aggregation of a time series — temporal_aggregation","title":"Temporal aggregation of a time series — temporal_aggregation","text":"Creates list aggregated time series time series class ts.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/temporal_aggregation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal aggregation of a time series — temporal_aggregation","text":"","code":"temporal_aggregation(y, agg_levels = NULL)"},{"path":"https://idsia.github.io/bayesRecon/reference/temporal_aggregation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal aggregation of a time series — temporal_aggregation","text":"y univariate time series class ts. agg_levels user-selected list aggregation levels.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/temporal_aggregation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal aggregation of a time series — temporal_aggregation","text":"list ts objects containing aggregates time series order defined agg_levels.","code":""},{"path":"https://idsia.github.io/bayesRecon/reference/temporal_aggregation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Temporal aggregation of a time series — temporal_aggregation","text":"agg_levels=NULL agg_levels automatically generated taking factors time series frequency.","code":""},{"path":[]},{"path":"https://idsia.github.io/bayesRecon/reference/temporal_aggregation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporal aggregation of a time series — temporal_aggregation","text":"","code":"# Create a monthly count time series with 100 observations y <- ts(data=stats::rpois(100,lambda = 2),frequency = 12)  # Create the aggregate time series according to agg_levels y_agg <- temporal_aggregation(y,agg_levels = c(2,3,4,6,12))  # Show annual aggregate time series print(y_agg$`f=1`) #> Time Series: #> Start = 1.333333  #> End = 8.333333  #> Frequency = 1  #> [1] 24 13 20 19 28 19 30 18"},{"path":"https://idsia.github.io/bayesRecon/news/index.html","id":"bayesrecon-033","dir":"Changelog","previous_headings":"","what":"bayesRecon 0.3.3","title":"bayesRecon 0.3.3","text":"Minor bug fixes.","code":""},{"path":"https://idsia.github.io/bayesRecon/news/index.html","id":"bayesrecon-032","dir":"Changelog","previous_headings":"","what":"bayesRecon 0.3.2","title":"bayesRecon 0.3.2","text":"CRAN release: 2024-11-04 Fixed issues tests run compatibility issues new version waldo. Added new tests limit usage mixCond, TDcond BUIS. Added GitHub URL BugReports URL DESCRIPTION.","code":""},{"path":"https://idsia.github.io/bayesRecon/news/index.html","id":"bayesrecon-031","dir":"Changelog","previous_headings":"","what":"bayesRecon 0.3.1","title":"bayesRecon 0.3.1","text":"CRAN release: 2024-08-28 IMPORTANT CHANGE API reconc_* functions: now require aggregation matrix summing matrix S. examples section reconc_TDcond now contains example showing handle case unbalanced hierarchy.","code":""},{"path":"https://idsia.github.io/bayesRecon/news/index.html","id":"bayesrecon-030","dir":"Changelog","previous_headings":"","what":"bayesRecon 0.3.0","title":"bayesRecon 0.3.0","text":"CRAN release: 2024-05-29 Added reconc_MixCond, implementation Mixed conditioning reconciliation mixed-type hierarchical forecasts. Added reconc_TDcond, implementation Top-conditioning reconciliation mixed-type hierarchical forecasts. Vignette “Reconciliation M5 hierarchy mixed-type forecasts”. Added functions PMF.get_mean, PMF.get_quantile, PMF.get_var, PMF.sample, PMF.summary return point estimates samples probability mass function object. Added dataset M5_CA1_basefc contains base forecasts store “CA1” hierarchical time series M5 competition.","code":""},{"path":"https://idsia.github.io/bayesRecon/news/index.html","id":"bayesrecon-020","dir":"Changelog","previous_headings":"","what":"bayesRecon 0.2.0","title":"bayesRecon 0.2.0","text":"CRAN release: 2023-12-19 Vignette “Properties reconciled distribution via conditioning”. Added option reconc_BUIS pass base forecast parameters samples. Added option reconc_BUIS input list distributions instead string. Fixed bugs closed github issues.","code":""},{"path":"https://idsia.github.io/bayesRecon/news/index.html","id":"bayesrecon-012","dir":"Changelog","previous_headings":"","what":"bayesRecon 0.1.2","title":"bayesRecon 0.1.2","text":"CRAN release: 2023-08-24 Vignette “Probabilistic Reconciliation via Conditioning bayesRecon”. Added schaferStrimmer_cov function. Fixed bugs.","code":""},{"path":"https://idsia.github.io/bayesRecon/news/index.html","id":"bayesrecon-011","dir":"Changelog","previous_headings":"","what":"bayesRecon 0.1.1","title":"bayesRecon 0.1.1","text":"CRAN release: 2023-06-09 Added NEWS.md file track changes package. Fixed issue cause test fails machines.","code":""},{"path":"https://idsia.github.io/bayesRecon/news/index.html","id":"bayesrecon-010","dir":"Changelog","previous_headings":"","what":"bayesRecon 0.1.0","title":"bayesRecon 0.1.0","text":"CRAN release: 2023-05-26 Initial release package.","code":""}]
